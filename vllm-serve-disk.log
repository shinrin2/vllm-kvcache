INFO 06-15 14:53:52 [__init__.py:243] Automatically detected platform cuda.
INFO 06-15 14:53:54 [__init__.py:31] Available plugins for group vllm.general_plugins:
INFO 06-15 14:53:54 [__init__.py:33] - lora_filesystem_resolver -> vllm.plugins.lora_resolvers.filesystem_resolver:register_filesystem_resolver
INFO 06-15 14:53:54 [__init__.py:36] All plugins in this group will be loaded. Set `VLLM_PLUGINS` to control which plugins to load.
INFO 06-15 14:53:55 [api_server.py:1289] vLLM API server version 0.9.0
INFO 06-15 14:53:55 [cli_args.py:300] non-default args: {'max_model_len': 16384, 'kv_transfer_config': KVTransferConfig(kv_connector='LMCacheConnectorV1', engine_id='42a245fb-6115-4af4-a553-0bf1c73dcbbe', kv_buffer_device='cuda', kv_buffer_size=1000000000.0, kv_role='kv_both', kv_rank=None, kv_parallel_size=1, kv_ip='127.0.0.1', kv_port=14579, kv_connector_extra_config={}, kv_connector_module_path=None)}
INFO 06-15 14:54:01 [config.py:793] This model supports multiple tasks: {'reward', 'embed', 'generate', 'classify', 'score'}. Defaulting to 'generate'.
INFO 06-15 14:54:01 [config.py:2118] Chunked prefill is enabled with max_num_batched_tokens=2048.
INFO 06-15 14:54:04 [__init__.py:243] Automatically detected platform cuda.
INFO 06-15 14:54:06 [core.py:438] Waiting for init message from front-end.
INFO 06-15 14:54:06 [__init__.py:31] Available plugins for group vllm.general_plugins:
INFO 06-15 14:54:06 [__init__.py:33] - lora_filesystem_resolver -> vllm.plugins.lora_resolvers.filesystem_resolver:register_filesystem_resolver
INFO 06-15 14:54:06 [__init__.py:36] All plugins in this group will be loaded. Set `VLLM_PLUGINS` to control which plugins to load.
INFO 06-15 14:54:06 [core.py:65] Initializing a V1 LLM engine (v0.9.0) with config: model='meta-llama/Llama-3.1-8B-Instruct', speculative_config=None, tokenizer='meta-llama/Llama-3.1-8B-Instruct', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, override_neuron_config={}, tokenizer_revision=None, trust_remote_code=False, dtype=torch.bfloat16, max_seq_len=16384, download_dir=None, load_format=LoadFormat.AUTO, tensor_parallel_size=1, pipeline_parallel_size=1, disable_custom_all_reduce=False, quantization=None, enforce_eager=False, kv_cache_dtype=auto,  device_config=cuda, decoding_config=DecodingConfig(backend='auto', disable_fallback=False, disable_any_whitespace=False, disable_additional_properties=False, reasoning_backend=''), observability_config=ObservabilityConfig(show_hidden_metrics_for_version=None, otlp_traces_endpoint=None, collect_detailed_traces=None), seed=0, served_model_name=meta-llama/Llama-3.1-8B-Instruct, num_scheduler_steps=1, multi_step_stream_outputs=True, enable_prefix_caching=True, chunked_prefill_enabled=True, use_async_output_proc=True, pooler_config=None, compilation_config={"level": 3, "custom_ops": ["none"], "splitting_ops": ["vllm.unified_attention", "vllm.unified_attention_with_output"], "compile_sizes": [], "inductor_compile_config": {"enable_auto_functionalized_v2": false}, "use_cudagraph": true, "cudagraph_num_of_warmups": 1, "cudagraph_capture_sizes": [512, 504, 496, 488, 480, 472, 464, 456, 448, 440, 432, 424, 416, 408, 400, 392, 384, 376, 368, 360, 352, 344, 336, 328, 320, 312, 304, 296, 288, 280, 272, 264, 256, 248, 240, 232, 224, 216, 208, 200, 192, 184, 176, 168, 160, 152, 144, 136, 128, 120, 112, 104, 96, 88, 80, 72, 64, 56, 48, 40, 32, 24, 16, 8, 4, 2, 1], "max_capture_size": 512}
WARNING 06-15 14:54:07 [utils.py:2671] Methods determine_num_available_blocks,device_config,get_cache_block_size_bytes,initialize_cache not implemented in <vllm.v1.worker.gpu_worker.Worker object at 0x78ae58cd4b00>
INFO 06-15 14:54:07 [parallel_state.py:1064] rank 0 in world size 1 is assigned as DP rank 0, PP rank 0, TP rank 0, EP rank 0
INFO 06-15 14:54:07 [factory.py:73] Creating v1 connector with name: LMCacheConnectorV1
WARNING 06-15 14:54:07 [base.py:61] Initializing KVConnectorBase_V1. This API is experimental and subject to change in the future as we iterate the design.
INFO 06-15 14:54:13 [topk_topp_sampler.py:48] Using FlashInfer for top-p & top-k sampling.
INFO 06-15 14:54:13 [gpu_model_runner.py:1531] Starting to load model meta-llama/Llama-3.1-8B-Instruct...
INFO 06-15 14:54:13 [cuda.py:217] Using Flash Attention backend on V1 engine.
INFO 06-15 14:54:13 [backends.py:35] Using InductorAdaptor
INFO 06-15 14:54:13 [weight_utils.py:291] Using model weights format ['*.safetensors']
INFO 06-15 14:54:16 [default_loader.py:280] Loading weights took 2.52 seconds
INFO 06-15 14:54:16 [gpu_model_runner.py:1549] Model loading took 14.9889 GiB and 3.058582 seconds
INFO 06-15 14:54:21 [backends.py:459] Using cache directory: /root/.cache/vllm/torch_compile_cache/165d9df4dc/rank_0_0 for vLLM's torch.compile
INFO 06-15 14:54:21 [backends.py:469] Dynamo bytecode transform time: 4.47 s
INFO 06-15 14:54:24 [backends.py:132] Directly load the compiled graph(s) for shape None from the cache, took 3.297 s
INFO 06-15 14:54:25 [monitor.py:33] torch.compile takes 4.47 s in total
INFO 06-15 14:54:25 [kv_cache_utils.py:637] GPU KV cache size: 93,056 tokens
INFO 06-15 14:54:25 [kv_cache_utils.py:640] Maximum concurrency for 16,384 tokens per request: 5.68x
INFO 06-15 14:54:45 [gpu_model_runner.py:1933] Graph capturing finished in 19 secs, took 0.55 GiB
INFO 06-15 14:54:45 [core.py:167] init engine (profile, create kv cache, warmup model) took 28.39 seconds
INFO 06-15 14:54:45 [factory.py:73] Creating v1 connector with name: LMCacheConnectorV1
WARNING 06-15 14:54:45 [base.py:61] Initializing KVConnectorBase_V1. This API is experimental and subject to change in the future as we iterate the design.
INFO 06-15 14:54:45 [loggers.py:134] vllm cache_config_info with initialization after num_gpu_blocks is: 5816
WARNING 06-15 14:54:45 [config.py:1339] Default sampling parameters have been overridden by the model's Hugging Face generation config recommended from the model creator. If this is not intended, please relaunch vLLM instance with `--generation-config vllm`.
INFO 06-15 14:54:45 [serving_chat.py:117] Using default chat sampling params from model: {'temperature': 0.6, 'top_p': 0.9}
INFO 06-15 14:54:45 [serving_completion.py:65] Using default completion sampling params from model: {'temperature': 0.6, 'top_p': 0.9}
INFO 06-15 14:54:45 [api_server.py:1336] Starting vLLM API server on http://0.0.0.0:8000
INFO 06-15 14:54:45 [launcher.py:28] Available routes are:
INFO 06-15 14:54:45 [launcher.py:36] Route: /openapi.json, Methods: GET, HEAD
INFO 06-15 14:54:45 [launcher.py:36] Route: /docs, Methods: GET, HEAD
INFO 06-15 14:54:45 [launcher.py:36] Route: /docs/oauth2-redirect, Methods: GET, HEAD
INFO 06-15 14:54:45 [launcher.py:36] Route: /redoc, Methods: GET, HEAD
INFO 06-15 14:54:45 [launcher.py:36] Route: /health, Methods: GET
INFO 06-15 14:54:45 [launcher.py:36] Route: /load, Methods: GET
INFO 06-15 14:54:45 [launcher.py:36] Route: /ping, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /ping, Methods: GET
INFO 06-15 14:54:45 [launcher.py:36] Route: /tokenize, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /detokenize, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/models, Methods: GET
INFO 06-15 14:54:45 [launcher.py:36] Route: /version, Methods: GET
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/chat/completions, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/completions, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/embeddings, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /pooling, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /classify, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /score, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/score, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/audio/transcriptions, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /rerank, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v1/rerank, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /v2/rerank, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /invocations, Methods: POST
INFO 06-15 14:54:45 [launcher.py:36] Route: /metrics, Methods: GET
INFO:     127.0.0.1:56000 - "GET /v1/models HTTP/1.1" 200 OK
INFO 06-15 14:54:57 [chat_utils.py:419] Detected the chat template content format to be 'string'. You can set `--chat-template-content-format` to override this.
INFO 06-15 14:54:57 [logger.py:42] Received request chatcmpl-0e66b941b5794f36b1fcc3833574dcff: prompt: '<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 26 Jul 2024\n\n<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nBASH(1)                                 General Commands Manual                                BASH(1)\n\nNAME\n       bash - GNU Bourne-Again SHell\n\nSYNOPSIS\n       bash [options] [command_string | file]\n\nCOPYRIGHT\n       Bash is Copyright (C) 1989-2020 by the Free Software Foundation, Inc.\n\nDESCRIPTION\n       Bash  is  an  sh-compatible  command  language interpreter that executes commands read from the\n       standard input or from a file.  Bash also incorporates useful features  from  the  Korn  and  C\n       shells (ksh and csh).\n\n       Bash  is  intended  to be a conformant implementation of the Shell and Utilities portion of the\n       IEEE POSIX specification (IEEE Standard 1003.1).  Bash can be configured to be POSIX-conformant\n       by default.\n\nOPTIONS\n       All of the single-character shell options documented in the description of the set builtin com‐\n       mand, including -o, can be used as options when the shell is invoked.  In addition, bash inter‐\n       prets the following options when it is invoked:\n\n       -c        If  the  -c option is present, then commands are read from the first non-option argu‐\n                 ment command_string.  If there are arguments after the command_string, the first  ar‐\n                 gument  is  assigned to $0 and any remaining arguments are assigned to the positional\n                 parameters.  The assignment to $0 sets the name of the shell, which is used in  warn‐\n                 ing and error messages.\n       -i        If the -i option is present, the shell is interactive.\n       -l        Make bash act as if it had been invoked as a login shell (see INVOCATION below).\n       -r        If  the  -r option is present, the shell becomes restricted (see RESTRICTED SHELL be‐\n                 low).\n       -s        If the -s option is present, or if no arguments remain after option processing,  then\n                 commands are read from the standard input.  This option allows the positional parame‐\n                 ters to be set when invoking an interactive shell or when  reading  input  through  a\n                 pipe.\n       -v        Print shell input lines as they are read.\n       -x        Print commands and their arguments as they are executed.\n       -D        A  list of all double-quoted strings preceded by $ is printed on the standard output.\n                 These are the strings that are subject to language translation when the  current  lo‐\n                 cale is not C or POSIX.  This implies the -n option; no commands will be executed.\n       [-+]O [shopt_option]\n                 shopt_option  is  one  of  the shell options accepted by the shopt builtin (see SHELL\n                 BUILTIN COMMANDS below).  If shopt_option is present, -O sets the value of  that  op‐\n                 tion;  +O  unsets  it.   If shopt_option is not supplied, the names and values of the\n                 shell options accepted by shopt are printed on the standard output.  If  the  invoca‐\n                 tion option is +O, the output is displayed in a format that may be reused as input.\n       --        A  --  signals  the end of options and disables further option processing.  Any argu‐\n                 ments after the -- are treated as filenames and  arguments.   An  argument  of  -  is\n                 equivalent to --.\n\n       Bash  also  interprets  a  number of multi-character options.  These options must appear on the\n       command line before the single-character options to be recognized.\n\n       --debugger\n              Arrange for the debugger profile to be executed before the shell starts.  Turns  on  ex‐\n              tended  debugging  mode (see the description of the extdebug option to the shopt builtin\n              below).\n       --dump-po-strings\n              Equivalent to -D, but the output is in the GNU gettext po (portable object) file format.\n       --dump-strings\n              Equivalent to -D.\n       --help Display a usage message on standard output and exit successfully.\n       --init-file file\n       --rcfile file\n              Execute  commands  from  file  instead  of   the   system   wide   initialization   file\n              /etc/bash.bashrc and the standard personal initialization file ~/.bashrc if the shell is\n              interactive (see INVOCATION below).\n\n       --login\n              Equivalent to -l.\n\n       --noediting\n              Do not use the GNU readline library to read command lines when the shell is interactive.\n\n       --noprofile\n              Do not read either the system-wide startup file /etc/profile or any of the personal ini‐\n              tialization files ~/.bash_profile, ~/.bash_login, or ~/.profile.  By default, bash reads\n              these files when it is invoked as a login shell (see INVOCATION below).\n\n       --norc Do not read and execute the system wide initialization  file  /etc/bash.bashrc  and  the\n              personal  initialization  file ~/.bashrc if the shell is interactive.  This option is on\n              by default if the shell is invoked as sh.\n\n       --posix\n              Change the behavior of bash where the default operation differs from the POSIX  standard\n              to  match  the  standard (posix mode).  See SEE ALSO below for a reference to a document\n              that details how posix mode affects bash\'s behavior.\n\n       --restricted\n              The shell becomes restricted (see RESTRICTED SHELL below).\n\n       --verbose\n              Equivalent to -v.\n\n       --version\n              Show version information for this instance of bash on the standard output and exit  suc‐\n              cessfully.\n\nARGUMENTS\n       If arguments remain after option processing, and neither the -c nor the -s option has been sup‐\n       plied, the first argument is assumed to be the name of a file containing  shell  commands.   If\n       bash  is invoked in this fashion, $0 is set to the name of the file, and the positional parame‐\n       ters are set to the remaining arguments.  Bash reads and executes commands from this file, then\n       exits.   Bash\'s  exit status is the exit status of the last command executed in the script.  If\n       no commands are executed, the exit status is 0.  An attempt is first made to open the  file  in\n       the  current  directory,  and,  if no file is found, then the shell searches the directories in\n       PATH for the script.\n\nINVOCATION\n       A login shell is one whose first character of argument zero is a -, or  one  started  with  the\n       --login option.\n\n       An  interactive  shell is one started without non-option arguments (unless -s is specified) and\n       without the -c option whose standard input and error are both connected to terminals (as deter‐\n       mined  by  isatty(3)), or one started with the -i option.  PS1 is set and $- includes i if bash\n       is interactive, allowing a shell script or a startup file to test this state.\n\n       The following paragraphs describe how bash executes its startup files.  If any of the files ex‐\n       ist  but  cannot be read, bash reports an error.  Tildes are expanded in filenames as described\n       below under Tilde Expansion in the EXPANSION section.\n\n       When bash is invoked as an interactive login shell, or as  a  non-interactive  shell  with  the\n       --login  option,  it first reads and executes commands from the file /etc/profile, if that file\n       exists.  After reading that file, it looks for ~/.bash_profile, ~/.bash_login, and  ~/.profile,\n       in  that order, and reads and executes commands from the first one that exists and is readable.\n       The --noprofile option may be used when the shell is started to inhibit this behavior.\n\n       When an interactive login shell exits, or a  non-interactive  login  shell  executes  the  exit\n       builtin command, bash reads and executes commands from the file ~/.bash_logout, if it exists.\n\n       When  an  interactive  shell that is not a login shell is started, bash reads and executes com‐\n       mands from /etc/bash.bashrc and ~/.bashrc, if these files exist.  This may be inhibited by  us‐\n       ing  the  --norc option.  The --rcfile file option will force bash to read and execute commands\n       from file instead of /etc/bash.bashrc and ~/.bashrc.\n\n       When bash is started non-interactively, to run a shell script, for example, it  looks  for  the\n       variable  BASH_ENV  in the environment, expands its value if it appears there, and uses the ex‐\n       panded value as the name of a file to read and execute.  Bash behaves as if the following  com‐\n       mand were executed:\n              if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\n       but the value of the PATH variable is not used to search for the filename.\n\n       If  bash is invoked with the name sh, it tries to mimic the startup behavior of historical ver‐\n       sions of sh as closely as possible, while conforming to the POSIX standard as well.   When  in‐\n       voked  as  an  interactive  login shell, or a non-interactive shell with the --login option, it\n       first attempts to read and execute commands from /etc/profile and ~/.profile,  in  that  order.\n       The  --noprofile  option  may be used to inhibit this behavior.  When invoked as an interactive\n       shell with the name sh, bash looks for the variable ENV, expands its value if  it  is  defined,\n       and  uses  the expanded value as the name of a file to read and execute.  Since a shell invoked\n       as sh does not attempt to read and execute commands from any other startup files, the  --rcfile\n       option  has  no  effect.   A non-interactive shell invoked with the name sh does not attempt to\n       read any other startup files.  When invoked as sh, bash enters posix  mode  after  the  startup\n       files are read.\n\n       When  bash  is  started  in posix mode, as with the --posix command line option, it follows the\n       POSIX standard for startup files.  In this mode, interactive shells expand the ENV variable and\n       commands  are  read  and  executed  from  the  file whose name is the expanded value.  No other\n       startup files are read.\n\n       Bash attempts to determine when it is being run with its standard input connected to a  network\n       connection, as when executed by the remote shell daemon, usually rshd, or the secure shell dae‐\n       mon sshd.  If bash determines it is being run in this fashion, it reads and  executes  commands\n       from  ~/.bashrc  and  ~/.bashrc, if these files exist and are readable.  It will not do this if\n       invoked as sh.  The --norc option may be used to inhibit this behavior, and the --rcfile option\n       may  be  used  to force another file to be read, but neither rshd nor sshd generally invoke the\n       shell with those options or allow them to be specified.\n\n       If the shell is started with the effective user (group) id not equal to the real  user  (group)\n       id,  and  the -p option is not supplied, no startup files are read, shell functions are not in‐\n       herited from the environment, the SHELLOPTS, BASHOPTS, CDPATH,  and  GLOBIGNORE  variables,  if\n       they  appear in the environment, are ignored, and the effective user id is set to the real user\n       id.  If the -p option is supplied at invocation, the startup behavior is the same, but the  ef‐\n       fective user id is not reset.\n\nDEFINITIONS\n       The following definitions are used throughout the rest of this document.\n       blank  A space or tab.\n       word   A  sequence of characters considered as a single unit by the shell.  Also known as a to‐\n              ken.\n       name   A word consisting only of alphanumeric characters and underscores, and beginning with an\n              alphabetic character or an underscore.  Also referred to as an identifier.\n       metacharacter\n              A character that, when unquoted, separates words.  One of the following:\n              |  & ; ( ) < > space tab newline\n       control operator\n              A token that performs a control function.  It is one of the following symbols:\n              || & && ; ;; ;& ;;& ( ) | |& <newline>\n\nRESERVED WORDS\n       Reserved  words  are  words  that have a special meaning to the shell.  The following words are\n       recognized as reserved when unquoted and either the first word of a command (see SHELL  GRAMMAR\n       below),  the  third word of a case or select command (only in is valid), or the third word of a\n       for command (only in and do are valid):\n\n       ! case  coproc  do done elif else esac fi for function if in select then until while {  }  time\n       [[ ]]\n\nSHELL GRAMMAR\n   Simple Commands\n       A  simple  command  is  a sequence of optional variable assignments followed by blank-separated\n       words and redirections, and terminated by a control operator.  The  first  word  specifies  the\n       command  to be executed, and is passed as argument zero.  The remaining words are passed as ar‐\n       guments to the invoked command.\n\n       The return value of a simple command is its exit status, or 128+n if the command is  terminated\n       by signal n.\n\n   Pipelines\n       A pipeline is a sequence of one or more commands separated by one of the control operators | or\n       |&.  The format for a pipeline is:\n\n              [time [-p]] [ ! ] command [ [|⎪|&] command2 ... ]\n\n       The standard output of command is connected via a pipe to the standard input of command2.  This\n       connection  is  performed before any redirections specified by the command (see REDIRECTION be‐\n       low).  If |& is used, command\'s standard error, in addition to its  standard  output,  is  con‐\n       nected  to  command2\'s  standard  input through the pipe; it is shorthand for 2>&1 |.  This im‐\n       plicit redirection of the standard error to the standard output is performed after any redirec‐\n       tions specified by the command.\n\n       The return status of a pipeline is the exit status of the last command, unless the pipefail op‐\n       tion is enabled.  If pipefail is enabled, the pipeline\'s return status is the value of the last\n       (rightmost)  command to exit with a non-zero status, or zero if all commands exit successfully.\n       If the reserved word !  precedes a pipeline, the exit status of that pipeline  is  the  logical\n       negation  of the exit status as described above.  The shell waits for all commands in the pipe‐\n       line to terminate before returning a value.\n\n       If the time reserved word precedes a pipeline, the elapsed as well as user and system time con‐\n       sumed  by  its  execution are reported when the pipeline terminates.  The -p option changes the\n       output format to that specified by POSIX.  When the shell is in posix mode, it does not  recog‐\n       nize  time as a reserved word if the next token begins with a `-\'.  The TIMEFORMAT variable may\n       be set to a format string that specifies how the timing information should  be  displayed;  see\n       the description of TIMEFORMAT under Shell Variables below.\n\n       When  the  shell  is in posix mode, time may be followed by a newline.  In this case, the shell\n       displays the total user and system time consumed by the shell and its children.  The TIMEFORMAT\n       variable may be used to specify the format of the time information.\n\n       Each  command  in a pipeline is executed as a separate process (i.e., in a subshell).  See COM‐\n       MAND EXECUTION ENVIRONMENT for a description of a subshell environment.  If the lastpipe option\n       is  enabled using the shopt builtin (see the description of shopt below), the last element of a\n       pipeline may be run by the shell process.\n\n   Lists\n       A list is a sequence of one or more pipelines separated by one of the operators ;,  &,  &&,  or\n       ||, and optionally terminated by one of ;, &, or <newline>.\n\n       Of these list operators, && and || have equal precedence, followed by ; and &, which have equal\n       precedence.\n\n       A sequence of one or more newlines may appear in a list instead of a semicolon to delimit  com‐\n       mands.\n\n       If  a  command  is  terminated by the control operator &, the shell executes the command in the\n       background in a subshell.  The shell does not wait for the command to finish,  and  the  return\n       status  is  0.   These are referred to as asynchronous commands.  Commands separated by a ; are\n       executed sequentially; the shell waits for each command to terminate in turn.  The return  sta‐\n       tus is the exit status of the last command executed.\n\n       AND  and OR lists are sequences of one or more pipelines separated by the && and || control op‐\n       erators, respectively.  AND and OR lists are executed with left associativity.  An AND list has\n       the form\n\n              command1 && command2\n\n       command2 is executed if, and only if, command1 returns an exit status of zero (success).\n\n       An OR list has the form\n\n              command1 || command2\n\n       command2 is executed if, and only if, command1 returns a non-zero exit status.  The return sta‐\n       tus of AND and OR lists is the exit status of the last command executed in the list.\n\n   Compound Commands\n       A compound command is one of the following.  In most cases a list in  a  command\'s  description\n       may be separated from the rest of the command by one or more newlines, and may be followed by a\n       newline in place of a semicolon.\n\n       (list) list is executed in a subshell environment (see COMMAND  EXECUTION  ENVIRONMENT  below).\n              Variable assignments and builtin commands that affect the shell\'s environment do not re‐\n              main in effect after the command completes.  The return status is  the  exit  status  of\n              list.\n\n       { list; }\n              list  is simply executed in the current shell environment.  list must be terminated with\n              a newline or semicolon.  This is known as a group command.  The  return  status  is  the\n              exit  status of list.  Note that unlike the metacharacters ( and ), { and } are reserved\n              words and must occur where a reserved word is permitted to be recognized.  Since they do\n              not  cause a word break, they must be separated from list by whitespace or another shell\n              metacharacter.\n\n       ((expression))\n              The expression is evaluated according to the  rules  described  below  under  ARITHMETIC\n              EVALUATION.   If the value of the expression is non-zero, the return status is 0; other‐\n              wise the return status is 1.  This is exactly equivalent to let "expression".\n\n       [[ expression ]]\n              Return a status of 0 or 1 depending on the evaluation of the conditional expression  ex‐\n              pression.   Expressions  are composed of the primaries described below under CONDITIONAL\n              EXPRESSIONS.  Word splitting and pathname expansion are not performed on the  words  be‐\n              tween  the  [[ and ]]; tilde expansion, parameter and variable expansion, arithmetic ex‐\n              pansion, command substitution, process substitution, and quote  removal  are  performed.\n              Conditional operators such as -f must be unquoted to be recognized as primaries.\n\n              When  used  with  [[, the < and > operators sort lexicographically using the current lo‐\n              cale.\n\n       See the description of the test builtin command (section SHELL BUILTIN COMMANDS below) for  the\n       handling of parameters (i.e.  missing parameters).\n\n       When  the == and != operators are used, the string to the right of the operator is considered a\n       pattern and matched according to the rules described below under Pattern Matching,  as  if  the\n       extglob  shell  option  were  enabled.  The = operator is equivalent to ==.  If the nocasematch\n       shell option is enabled, the match is performed without regard to the case of alphabetic  char‐\n       acters.   The  return value is 0 if the string matches (==) or does not match (!=) the pattern,\n       and 1 otherwise.  Any part of the pattern may be quoted to  force  the  quoted  portion  to  be\n       matched as a string.\n\n       An  additional  binary operator, =~, is available, with the same precedence as == and !=.  When\n       it is used, the string to the right of the operator is considered a POSIX extended regular  ex‐\n       pression  and  matched  accordingly (using the POSIX regcomp and regexec interfaces usually de‐\n       scribed in regex(3)).  The return value is 0 if the string matches the pattern,  and  1  other‐\n       wise.   If  the regular expression is syntactically incorrect, the conditional expression\'s re‐\n       turn value is 2.  If the nocasematch shell option is enabled, the match  is  performed  without\n       regard  to  the  case of alphabetic characters.  Any part of the pattern may be quoted to force\n       the quoted portion to be matched as a string.  Bracket expressions in regular expressions  must\n       be treated carefully, since normal quoting characters lose their meanings between brackets.  If\n       the pattern is stored in a shell variable, quoting the variable  expansion  forces  the  entire\n       pattern to be matched as a string.\n\n       The  pattern  will  match if it matches any part of the string.  Anchor the pattern using the ^\n       and $ regular expression operators to force it to match the entire string.  The array  variable\n       BASH_REMATCH  records  which  parts of the string matched the pattern.  The element of BASH_RE‐\n       MATCH with index 0 contains the portion of the string matching the entire  regular  expression.\n       Substrings  matched  by parenthesized subexpressions within the regular expression are saved in\n       the remaining BASH_REMATCH indices. The element of BASH_REMATCH with index n is the portion  of\n       the string matching the nth parenthesized subexpression.\n\n       Expressions may be combined using the following operators, listed in decreasing order of prece‐\n       dence:\n\n              ( expression )\n                     Returns the value of expression.  This may be used to override the normal  prece‐\n                     dence of operators.\n              ! expression\n                     True if expression is false.\n              expression1 && expression2\n                     True if both expression1 and expression2 are true.\n              expression1 || expression2\n                     True if either expression1 or expression2 is true.\n\n              The  && and || operators do not evaluate expression2 if the value of expression1 is suf‐\n              ficient to determine the return value of the entire conditional expression.\n\n       for name [ [ in [ word ... ] ] ; ] do list ; done\n              The list of words following in is expanded, generating a list of  items.   The  variable\n              name  is  set  to each element of this list in turn, and list is executed each time.  If\n              the in word is omitted, the for command executes list once for each positional parameter\n              that  is  set  (see PARAMETERS below).  The return status is the exit status of the last\n              command that executes.  If the expansion of the items following in results in  an  empty\n              list, no commands are executed, and the return status is 0.\n\n       for (( expr1 ; expr2 ; expr3 )) ; do list ; done\n              First, the arithmetic expression expr1 is evaluated according to the rules described be‐\n              low under ARITHMETIC EVALUATION.  The arithmetic expression expr2 is then evaluated  re‐\n              peatedly  until  it  evaluates  to zero.  Each time expr2 evaluates to a non-zero value,\n              list is executed and the arithmetic expression expr3 is evaluated.  If any expression is\n              omitted, it behaves as if it evaluates to 1.  The return value is the exit status of the\n              last command in list that is executed, or false if any of the expressions is invalid.\n\n       select name [ in word ] ; do list ; done\n              The list of words following in is expanded, generating a list of items.  The set of  ex‐\n              panded  words  is  printed  on the standard error, each preceded by a number.  If the in\n              word is omitted, the positional parameters are printed (see PARAMETERS below).  The  PS3\n              prompt  is then displayed and a line read from the standard input.  If the line consists\n              of a number corresponding to one of the displayed words, then the value of name  is  set\n              to  that  word.  If the line is empty, the words and prompt are displayed again.  If EOF\n              is read, the command completes.  Any other value read causes name to  be  set  to  null.\n              The line read is saved in the variable REPLY.  The list is executed after each selection\n              until a break command is executed.  The exit status of select is the exit status of  the\n              last command executed in list, or zero if no commands were executed.\n\n       case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n              A  case  command first expands word, and tries to match it against each pattern in turn,\n              using the matching rules described under Pattern Matching below.  The word  is  expanded\n              using  tilde  expansion, parameter and variable expansion, arithmetic expansion, command\n              substitution, process substitution and quote removal.  Each pattern examined is expanded\n              using  tilde  expansion, parameter and variable expansion, arithmetic expansion, command\n              substitution, and process substitution.  If the nocasematch shell option is enabled, the\n              match is performed without regard to the case of alphabetic characters.  When a match is\n              found, the corresponding list is executed.  If the ;; operator is  used,  no  subsequent\n              matches are attempted after the first pattern match.  Using ;& in place of ;; causes ex‐\n              ecution to continue with the list associated with the next set of patterns.   Using  ;;&\n              in  place of ;; causes the shell to test the next pattern list in the statement, if any,\n              and execute any associated list on a successful match, continuing the case statement ex‐\n              ecution  as  if the pattern list had not matched.  The exit status is zero if no pattern\n              matches.  Otherwise, it is the exit status of the last command executed in list.\n\n       if list; then list; [ elif list; then list; ] ... [ else list; ] fi\n              The if list is executed.  If its exit status is zero, the then list is executed.  Other‐\n              wise,  each  elif  list  is executed in turn, and if its exit status is zero, the corre‐\n              sponding then list is executed and the command completes.  Otherwise, the else  list  is\n              executed,  if present.  The exit status is the exit status of the last command executed,\n              or zero if no condition tested true.\n\n       while list-1; do list-2; done\n       until list-1; do list-2; done\n              The while command continuously executes the list list-2 as long as the last  command  in\n              the  list  list-1 returns an exit status of zero.  The until command is identical to the\n              while command, except that the test is negated: list-2 is executed as long as  the  last\n              command  in list-1 returns a non-zero exit status.  The exit status of the while and un‐\n              til commands is the exit status of the last command executed in list-2, or zero if  none\n              was executed.\n\n   Coprocesses\n       A  coprocess  is a shell command preceded by the coproc reserved word.  A coprocess is executed\n       asynchronously in a subshell, as if the command had been terminated with the &  control  opera‐\n       tor, with a two-way pipe established between the executing shell and the coprocess.\n\n       The format for a coprocess is:\n\n              coproc [NAME] command [redirections]\n\n       This  creates  a  coprocess  named  NAME.  If NAME is not supplied, the default name is COPROC.\n       NAME must not be supplied if command is a simple command (see above); otherwise, it  is  inter‐\n       preted as the first word of the simple command.  When the coprocess is executed, the shell cre‐\n       ates an array variable (see Arrays below) named NAME in the context  of  the  executing  shell.\n       The  standard  output  of command is connected via a pipe to a file descriptor in the executing\n       shell, and that file descriptor is assigned to NAME[0].  The standard input of command is  con‐\n       nected  via a pipe to a file descriptor in the executing shell, and that file descriptor is as‐\n       signed to NAME[1].  This pipe is established before any redirections specified by  the  command\n       (see  REDIRECTION  below).  The file descriptors can be utilized as arguments to shell commands\n       and redirections using standard word expansions.  Other than those created to  execute  command\n       and process substitutions, the file descriptors are not available in subshells.  The process ID\n       of the shell spawned to execute the coprocess  is  available  as  the  value  of  the  variable\n       NAME_PID.  The wait builtin command may be used to wait for the coprocess to terminate.\n\n       Since  the  coprocess  is created as an asynchronous command, the coproc command always returns\n       success.  The return status of a coprocess is the exit status of command.\n\n   Shell Function Definitions\n       A shell function is an object that is called like a simple command and executes a compound com‐\n       mand with a new set of positional parameters.  Shell functions are declared as follows:\n\n       fname () compound-command [redirection]\n       function fname [()] compound-command [redirection]\n              This  defines  a  function named fname.  The reserved word function is optional.  If the\n              function reserved word is supplied, the parentheses are optional.  The body of the func‐\n              tion  is the compound command compound-command (see Compound Commands above).  That com‐\n              mand is usually a list of commands between { and }, but may be any command listed  under\n              Compound  Commands above, with one exception: If the function reserved word is used, but\n              the parentheses are not supplied, the braces are required.  compound-command is executed\n              whenever  fname is specified as the name of a simple command.  When in posix mode, fname\n              must be a valid shell name and may not be the name of one of the POSIX special builtins.\n              In default mode, a function name can be any unquoted shell word that does not contain $.\n              Any redirections (see REDIRECTION below) specified when a function is defined  are  per‐\n              formed  when the function is executed.  The exit status of a function definition is zero\n              unless a syntax error occurs or a readonly function with the same name  already  exists.\n              When executed, the exit status of a function is the exit status of the last command exe‐\n              cuted in the body.  (See FUNCTIONS below.)\n\nCOMMENTS\n       In a non-interactive shell, or an interactive shell in which the interactive_comments option to\n       the shopt builtin is enabled (see SHELL BUILTIN COMMANDS below), a word beginning with # causes\n       that word and all remaining characters on that line to be ignored.  An interactive shell  with‐\n       out  the interactive_comments option enabled does not allow comments.  The interactive_comments\n       option is on by default in interactive shells.\n\nQUOTING\n       Quoting is used to remove the special meaning of certain characters  or  words  to  the  shell.\n       Quoting  can  be  used to disable special treatment for special characters, to prevent reserved\n       words from being recognized as such, and to prevent parameter expansion.\n\n       Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell  and\n       must be quoted if it is to represent itself.\n\n       When the command history expansion facilities are being used (see HISTORY EXPANSION below), the\n       history expansion character, usually !, must be quoted to prevent history expansion.\n\n       There are three quoting mechanisms: the escape character, single quotes, and double quotes.\n\n       A non-quoted backslash (\\) is the escape character.  It preserves the literal value of the next\n       character that follows, with the exception of <newline>.  If a \\<newline> pair appears, and the\n       backslash is not itself quoted, the \\<newline> is treated as a line continuation (that  is,  it\n       is removed from the input stream and effectively ignored).\n\n       Enclosing  characters in single quotes preserves the literal value of each character within the\n       quotes.  A single quote may not occur between single quotes, even when preceded by a backslash.\n\n       Enclosing characters in double quotes preserves the literal value of all characters within  the\n       quotes,  with  the  exception  of $, `, \\, and, when history expansion is enabled, !.  When the\n       shell is in posix mode, the ! has no special meaning within double quotes,  even  when  history\n       expansion  is  enabled.   The  characters  $  and  ` retain their special meaning within double\n       quotes.  The backslash retains its special meaning only when followed by one of  the  following\n       characters:  $,  `,  ",  \\, or <newline>.  A double quote may be quoted within double quotes by\n       preceding it with a backslash.  If enabled, history expansion will be  performed  unless  an  !\n       appearing in double quotes is escaped using a backslash.  The backslash preceding the !  is not\n       removed.\n\n       The special parameters * and @ have special meaning when in double quotes (see  PARAMETERS  be‐\n       low).\n\n       Words of the form $\'string\' are treated specially.  The word expands to string, with backslash-\n       escaped characters replaced as specified by the ANSI C standard.  Backslash  escape  sequences,\n       if present, are decoded as follows:\n              \\a     alert (bell)\n              \\b     backspace\n              \\e\n              \\E     an escape character\n              \\f     form feed\n              \\n     new line\n              \\r     carriage return\n              \\t     horizontal tab\n              \\v     vertical tab\n              \\\\     backslash\n              \\\'     single quote\n              \\"     double quote\n              \\?     question mark\n              \\nnn   the  eight-bit  character  whose value is the octal value nnn (one to three octal\n                     digits)\n              \\xHH   the eight-bit character whose value is the hexadecimal value HH (one or  two  hex\n                     digits)\n              \\uHHHH the  Unicode  (ISO/IEC 10646) character whose value is the hexadecimal value HHHH\n                     (one to four hex digits)\n              \\UHHHHHHHH\n                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHH‐\n                     HHH (one to eight hex digits)\n              \\cx    a control-x character\n\n       The expanded result is single-quoted, as if the dollar sign had not been present.\n\n       A double-quoted string preceded by a dollar sign ($"string") will cause the string to be trans‐\n       lated according to the current locale.  The gettext infrastructure performs the message catalog\n       lookup  and  translation, using the LC_MESSAGES and TEXTDOMAIN shell variables.  If the current\n       locale is C or POSIX, or if there are no translations available, the dollar  sign  is  ignored.\n       If the string is translated and replaced, the replacement is double-quoted.\n\nPARAMETERS\n       A parameter is an entity that stores values.  It can be a name, a number, or one of the special\n       characters listed below under Special Parameters.  A variable is a parameter denoted by a name.\n       A  variable has a value and zero or more attributes.  Attributes are assigned using the declare\n       builtin command (see declare below in SHELL BUILTIN COMMANDS).\n\n       A parameter is set if it has been assigned a value.  The null string is a valid value.  Once  a\n       variable  is  set,  it  may be unset only by using the unset builtin command (see SHELL BUILTIN\n       COMMANDS below).\n\n       A variable may be assigned to by a statement of the form\n\n              name=[value]\n\n       If value is not given, the variable is assigned the null string.  All values undergo tilde  ex‐\n       pansion,  parameter  and  variable  expansion,  command substitution, arithmetic expansion, and\n       quote removal (see EXPANSION below).  If the variable has its integer attribute set, then value\n       is evaluated as an arithmetic expression even if the $((...)) expansion is not used (see Arith‐\n       metic Expansion below).  Word splitting is not performed, with the exception  of  "$@"  as  ex‐\n       plained  below  under  Special  Parameters.   Pathname  expansion is not performed.  Assignment\n       statements may also appear as arguments to the alias, declare, typeset, export,  readonly,  and\n       local  builtin  commands (declaration commands).  When in posix mode, these builtins may appear\n       in a command after one or more instances of the command builtin  and  retain  these  assignment\n       statement properties.\n\n       In  the context where an assignment statement is assigning a value to a shell variable or array\n       index, the += operator can be used to append to or add to the variable\'s previous value.   This\n       includes  arguments to builtin commands such as declare that accept assignment statements (dec‐\n       laration commands).  When += is applied to a variable for which the integer attribute has  been\n       set,  value is evaluated as an arithmetic expression and added to the variable\'s current value,\n       which is also evaluated.  When += is applied to an array  variable  using  compound  assignment\n       (see  Arrays  below), the variable\'s value is not unset (as it is when using =), and new values\n       are appended to the array beginning at one greater than the array\'s maximum index (for  indexed\n       arrays)  or  added  as  additional  key-value pairs in an associative array.  When applied to a\n       string-valued variable, value is expanded and appended to the variable\'s value.\n\n       A variable can be assigned the nameref attribute using the -n option to the  declare  or  local\n       builtin  commands  (see  the descriptions of declare and local below) to create a nameref, or a\n       reference to another variable.  This allows variables to be manipulated  indirectly.   Whenever\n       the  nameref  variable is referenced, assigned to, unset, or has its attributes modified (other\n       than using or changing the nameref attribute itself), the operation is  actually  performed  on\n       the  variable  specified  by  the  nameref variable\'s value.  A nameref is commonly used within\n       shell functions to refer to a variable whose name is passed as an  argument  to  the  function.\n       For instance, if a variable name is passed to a shell function as its first argument, running\n              declare -n ref=$1\n       inside  the  function creates a nameref variable ref whose value is the variable name passed as\n       the first argument.  References and assignments to ref, and  changes  to  its  attributes,  are\n       treated  as references, assignments, and attribute modifications to the variable whose name was\n       passed as $1.  If the control variable in a for loop has the nameref  attribute,  the  list  of\n       words  can be a list of shell variables, and a name reference will be established for each word\n       in the list, in turn, when the loop is executed.  Array variables cannot be given  the  nameref\n       attribute.   However,  nameref  variables  can  reference array variables and subscripted array\n       variables.  Namerefs can be unset using the -n option to the unset builtin.  Otherwise, if  un‐\n       set  is executed with the name of a nameref variable as an argument, the variable referenced by\n       the nameref variable will be unset.\n\n   Positional Parameters\n       A positional parameter is a parameter denoted by one or more  digits,  other  than  the  single\n       digit 0.  Positional parameters are assigned from the shell\'s arguments when it is invoked, and\n       may be reassigned using the set builtin command.  Positional parameters may not be assigned  to\n       with  assignment  statements.   The positional parameters are temporarily replaced when a shell\n       function is executed (see FUNCTIONS below).\n\n       When a positional parameter consisting of more than a single digit is expanded, it must be  en‐\n       closed in braces (see EXPANSION below).\n\n   Special Parameters\n       The  shell  treats  several parameters specially.  These parameters may only be referenced; as‐\n       signment to them is not allowed.\n       *      Expands to the positional parameters, starting from one.   When  the  expansion  is  not\n              within double quotes, each positional parameter expands to a separate word.  In contexts\n              where it is performed, those words are subject to further word  splitting  and  pathname\n              expansion.   When the expansion occurs within double quotes, it expands to a single word\n              with the value of each parameter separated by the first character  of  the  IFS  special\n              variable.  That is, "$*" is equivalent to "$1c$2c...", where c is the first character of\n              the value of the IFS variable.  If IFS is unset, the parameters are separated by spaces.\n              If IFS is null, the parameters are joined without intervening separators.\n       @      Expands  to the positional parameters, starting from one.  In contexts where word split‐\n              ting is performed, this expands each positional parameter to a  separate  word;  if  not\n              within double quotes, these words are subject to word splitting.  In contexts where word\n              splitting is not performed, this expands to a single word with each positional parameter\n              separated  by  a  space.  When the expansion occurs within double quotes, each parameter\n              expands to a separate word.  That is, "$@" is equivalent to "$1" "$2" ...  If  the  dou‐\n              ble-quoted  expansion  occurs  within  a  word,  the expansion of the first parameter is\n              joined with the beginning part of the original word, and the expansion of the  last  pa‐\n              rameter is joined with the last part of the original word.  When there are no positional\n              parameters, "$@" and $@ expand to nothing (i.e., they are removed).\n       #      Expands to the number of positional parameters in decimal.\n       ?      Expands to the exit status of the most recently executed foreground pipeline.\n       -      Expands to the current option flags as specified upon invocation,  by  the  set  builtin\n              command, or those set by the shell itself (such as the -i option).\n       $      Expands  to the process ID of the shell.  In a () subshell, it expands to the process ID\n              of the current shell, not the subshell.\n       !      Expands to the process ID of the job most recently placed into the  background,  whether\n              executed as an asynchronous command or using the bg builtin (see JOB CONTROL below).\n       0      Expands  to the name of the shell or shell script.  This is set at shell initialization.\n              If bash is invoked with a file of commands, $0 is set to the name of that file.  If bash\n              is  started with the -c option, then $0 is set to the first argument after the string to\n              be executed, if one is present.  Otherwise, it is set to the  filename  used  to  invoke\n              bash, as given by argument zero.\n\n   Shell Variables\n       The following variables are set by the shell:\n\n       _      At shell startup, set to the pathname used to invoke the shell or shell script being ex‐\n              ecuted as passed in the environment or argument list.  Subsequently, expands to the last\n              argument  to  the  previous  simple command executed in the foreground, after expansion.\n              Also set to the full pathname used to invoke each command executed and placed in the en‐\n              vironment  exported  to that command.  When checking mail, this parameter holds the name\n              of the mail file currently being checked.\n       BASH   Expands to the full filename used to invoke this instance of bash.\n       BASHOPTS\n              A colon-separated list of enabled shell options.  Each word in the list is a valid argu‐\n              ment  for the -s option to the shopt builtin command (see SHELL BUILTIN COMMANDS below).\n              The options appearing in BASHOPTS are those reported as on by shopt.  If  this  variable\n              is in the environment when bash starts up, each shell option in the list will be enabled\n              before reading any startup files.  This variable is read-only.\n       BASHPID\n              Expands to the process ID of the current bash process.  This differs from $$ under  cer‐\n              tain  circumstances,  such  as  subshells that do not require bash to be re-initialized.\n              Assignments to BASHPID have no effect.  If BASHPID is unset, it loses its special  prop‐\n              erties, even if it is subsequently reset.\n       BASH_ALIASES\n              An  associative  array variable whose members correspond to the internal list of aliases\n              as maintained by the alias builtin.  Elements added to this array appear  in  the  alias\n              list;  however,  unsetting array elements currently does not cause aliases to be removed\n              from the alias list.  If BASH_ALIASES is unset, it loses its special properties, even if\n              it is subsequently reset.\n       BASH_ARGC\n              An array variable whose values are the number of parameters in each frame of the current\n              bash execution call stack.  The number of parameters to the  current  subroutine  (shell\n              function  or  script executed with . or source) is at the top of the stack.  When a sub‐\n              routine is executed, the number of parameters passed  is  pushed  onto  BASH_ARGC.   The\n              shell  sets  BASH_ARGC  only when in extended debugging mode (see the description of the\n              extdebug option to the shopt builtin below).   Setting  extdebug  after  the  shell  has\n              started  to execute a script, or referencing this variable when extdebug is not set, may\n              result in inconsistent values.\n       BASH_ARGV\n              An array variable containing all of the parameters in the current  bash  execution  call\n              stack.   The final parameter of the last subroutine call is at the top of the stack; the\n              first parameter of the initial call is at the bottom.  When a  subroutine  is  executed,\n              the  parameters  supplied are pushed onto BASH_ARGV.  The shell sets BASH_ARGV only when\n              in extended debugging mode (see the description of the  extdebug  option  to  the  shopt\n              builtin  below).   Setting  extdebug after the shell has started to execute a script, or\n              referencing this variable when extdebug is not set, may result in inconsistent values.\n       BASH_ARGV0\n              When referenced, this variable expands to the name of the shell or shell script (identi‐\n              cal  to $0; see the description of special parameter 0 above).  Assignment to BASH_ARGV0\n              causes the value assigned to also be assigned to $0.  If BASH_ARGV0 is unset,  it  loses\n              its special properties, even if it is subsequently reset.\n       BASH_CMDS\n              An  associative  array  variable  whose members correspond to the internal hash table of\n              commands as maintained by the hash builtin.  Elements added to this array appear in  the\n              hash  table; however, unsetting array elements currently does not cause command names to\n              be removed from the hash table.  If BASH_CMDS is unset, it loses its special properties,\n              even if it is subsequently reset.\n       BASH_COMMAND\n              The  command  currently being executed or about to be executed, unless the shell is exe‐\n              cuting a command as the result of a trap, in which case it is the command  executing  at\n              the  time  of the trap.  If BASH_COMMAND is unset, it loses its special properties, even\n              if it is subsequently reset.\n       BASH_EXECUTION_STRING\n              The command argument to the -c invocation option.\n       BASH_LINENO\n              An array variable whose members are the line numbers in source files where  each  corre‐\n              sponding  member  of FUNCNAME was invoked.  ${BASH_LINENO[$i]} is the line number in the\n              source   file   (${BASH_SOURCE[$i+1]})   where   ${FUNCNAME[$i]}    was    called    (or\n              ${BASH_LINENO[$i-1]} if referenced within another shell function).  Use LINENO to obtain\n              the current line number.\n       BASH_LOADABLES_PATH\n              A colon-separated list of directories in which the shell looks for dynamically  loadable\n              builtins specified by the enable command.\n       BASH_REMATCH\n              An  array variable whose members are assigned by the =~ binary operator to the [[ condi‐\n              tional command.  The element with index 0 is the portion of the string matching the  en‐\n              tire regular expression.  The element with index n is the portion of the string matching\n              the nth parenthesized subexpression.\n       BASH_SOURCE\n              An array variable whose members are the source filenames where the  corresponding  shell\n              function  names  in the FUNCNAME array variable are defined.  The shell function ${FUNC‐\n              NAME[$i]}   is   defined   in   the   file   ${BASH_SOURCE[$i]}    and    called    from\n              ${BASH_SOURCE[$i+1]}.\n       BASH_SUBSHELL\n              Incremented  by  one  within each subshell or subshell environment when the shell begins\n              executing in that environment.  The initial value is 0.  If BASH_SUBSHELL is  unset,  it\n              loses its special properties, even if it is subsequently reset.\n       BASH_VERSINFO\n              A  readonly  array  variable whose members hold version information for this instance of\n              bash.  The values assigned to the array members are as follows:\n              BASH_VERSINFO[0]        The major version number (the release).\n              BASH_VERSINFO[1]        The minor version number (the version).\n              BASH_VERSINFO[2]        The patch level.\n              BASH_VERSINFO[3]        The build version.\n              BASH_VERSINFO[4]        The release status (e.g., beta1).\n              BASH_VERSINFO[5]        The value of MACHTYPE.\n       BASH_VERSION\n              Expands to a string describing the version of this instance of bash.\n       COMP_CWORD\n              An index into ${COMP_WORDS} of the word containing the current  cursor  position.   This\n              variable is available only in shell functions invoked by the programmable completion fa‐\n              cilities (see Programmable Completion below).\n       COMP_KEY\n              The key (or final key of a key sequence) used to invoke the current completion function.\n       COMP_LINE\n              The current command line.  This variable is available only in shell functions and exter‐\n              nal commands invoked by the programmable completion facilities (see Programmable Comple‐\n              tion below).\n       COMP_POINT\n              The index of the current cursor position relative to the beginning of the  current  com‐\n              mand.  If the current cursor position is at the end of the current command, the value of\n              this variable is equal to ${#COMP_LINE}.  This variable is available only in shell func‐\n              tions  and external commands invoked by the programmable completion facilities (see Pro‐\n              grammable Completion below).\n       COMP_TYPE\n              Set to an integer value corresponding to the type of completion attempted that caused  a\n              completion function to be called: TAB, for normal completion, ?, for listing completions\n              after successive tabs, !, for listing alternatives on partial  word  completion,  @,  to\n              list  completions  if the word is not unmodified, or %, for menu completion.  This vari‐\n              able is available only in shell functions and external commands invoked by the  program‐\n              mable completion facilities (see Programmable Completion below).\n       COMP_WORDBREAKS\n              The  set of characters that the readline library treats as word separators when perform‐\n              ing word completion.  If COMP_WORDBREAKS is unset, it loses its special properties, even\n              if it is subsequently reset.\n       COMP_WORDS\n              An  array  variable (see Arrays below) consisting of the individual words in the current\n              command line.  The line is split into words as readline would split it, using COMP_WORD‐\n              BREAKS  as  described above.  This variable is available only in shell functions invoked\n              by the programmable completion facilities (see Programmable Completion below).\n       COPROC An array variable (see Arrays below) created to hold the  file  descriptors  for  output\n              from and input to an unnamed coprocess (see Coprocesses above).\n       DIRSTACK\n              An  array  variable  (see Arrays below) containing the current contents of the directory\n              stack.  Directories appear in the stack in the order they  are  displayed  by  the  dirs\n              builtin.   Assigning to members of this array variable may be used to modify directories\n              already in the stack, but the pushd and popd builtins must be used to add and remove di‐\n              rectories.   Assignment  to  this  variable  will  not change the current directory.  If\n              DIRSTACK is unset, it loses its special properties, even if it is subsequently reset.\n       EPOCHREALTIME\n              Each time this parameter is referenced, it expands to the number of  seconds  since  the\n              Unix  Epoch  (see time(3)) as a floating point value with micro-second granularity.  As‐\n              signments to EPOCHREALTIME are ignored.  If EPOCHREALTIME is unset, it loses its special\n              properties, even if it is subsequently reset.\n       EPOCHSECONDS\n              Each  time  this  parameter is referenced, it expands to the number of seconds since the\n              Unix Epoch (see time(3)).  Assignments to EPOCHSECONDS are ignored.  If EPOCHSECONDS  is\n              unset, it loses its special properties, even if it is subsequently reset.\n       EUID   Expands  to  the  effective  user  ID of the current user, initialized at shell startup.\n              This variable is readonly.\n       FUNCNAME\n              An array variable containing the names of all shell functions currently in the execution\n              call stack.  The element with index 0 is the name of any currently-executing shell func‐\n              tion.  The bottom-most element (the one with the highest index) is "main".   This  vari‐\n              able  exists  only  when a shell function is executing.  Assignments to FUNCNAME have no\n              effect.  If FUNCNAME is unset, it loses its special properties, even  if  it  is  subse‐\n              quently reset.\n\n              This  variable  can  be used with BASH_LINENO and BASH_SOURCE.  Each element of FUNCNAME\n              has corresponding elements in BASH_LINENO and BASH_SOURCE to describe  the  call  stack.\n              For instance, ${FUNCNAME[$i]} was called from the file ${BASH_SOURCE[$i+1]} at line num‐\n              ber ${BASH_LINENO[$i]}.  The caller builtin displays the current call stack  using  this\n              information.\n       GROUPS An  array  variable containing the list of groups of which the current user is a member.\n              Assignments to GROUPS have no effect.  If GROUPS is unset, it loses its special  proper‐\n              ties, even if it is subsequently reset.\n       HISTCMD\n              The  history  number, or index in the history list, of the current command.  Assignments\n              to HISTCMD are ignored.  If HISTCMD is unset, it loses its special properties,  even  if\n              it is subsequently reset.\n       HOSTNAME\n              Automatically set to the name of the current host.\n       HOSTTYPE\n              Automatically  set to a string that uniquely describes the type of machine on which bash\n              is executing.  The default is system-dependent.\n       LINENO Each time this parameter is referenced, the shell substitutes a  decimal  number  repre‐\n              senting  the  current  sequential line number (starting with 1) within a script or func‐\n              tion.  When not in a script or function, the value substituted is not guaranteed  to  be\n              meaningful.   If  LINENO is unset, it loses its special properties, even if it is subse‐\n              quently reset.\n       MACHTYPE\n              Automatically set to a string that fully describes the system type on which bash is exe‐\n              cuting, in the standard GNU cpu-company-system format.  The default is system-dependent.\n       MAPFILE\n              An  array  variable  (see  Arrays  below)  created  to hold the text read by the mapfile\n              builtin when no variable name is supplied.\n       OLDPWD The previous working directory as set by the cd command.\n       OPTARG The value of the last option argument processed by  the  getopts  builtin  command  (see\n              SHELL BUILTIN COMMANDS below).\n       OPTIND The index of the next argument to be processed by the getopts builtin command (see SHELL\n              BUILTIN COMMANDS below).\n       OSTYPE Automatically set to a string that describes the operating system on which bash is  exe‐\n              cuting.  The default is system-dependent.\n       PIPESTATUS\n              An  array  variable  (see Arrays below) containing a list of exit status values from the\n              processes in the most-recently-executed foreground pipeline (which may  contain  only  a\n              single command).\n       PPID   The process ID of the shell\'s parent.  This variable is readonly.\n       PWD    The current working directory as set by the cd command.\n       RANDOM Each  time  this  parameter  is referenced, it expands to a random integer between 0 and\n              32767.  Assigning a value to RANDOM initializes (seeds) the sequence of random  numbers.\n              If RANDOM is unset, it loses its special properties, even if it is subsequently reset.\n       READLINE_LINE\n              The contents of the readline line buffer, for use with "bind -x" (see SHELL BUILTIN COM‐\n              MANDS below).\n       READLINE_MARK\n              The position of the mark (saved insertion point) in the readline line  buffer,  for  use\n              with "bind -x" (see SHELL BUILTIN COMMANDS below).  The characters between the insertion\n              point and the mark are often called the region.\n       READLINE_POINT\n              The position of the insertion point in the readline line buffer, for use with "bind  -x"\n              (see SHELL BUILTIN COMMANDS below).\n       REPLY  Set  to  the  line  of input read by the read builtin command when no arguments are sup‐\n              plied.\n       SECONDS\n              Each time this parameter is referenced, the number of seconds since shell invocation  is\n              returned.   If a value is assigned to SECONDS, the value returned upon subsequent refer‐\n              ences is the number of seconds since the assignment plus the value assigned.  The number\n              of seconds at shell invocation and the current time is always determined by querying the\n              system clock.  If SECONDS is unset, it loses its special properties, even if it is  sub‐\n              sequently reset.\n       SHELLOPTS\n              A colon-separated list of enabled shell options.  Each word in the list is a valid argu‐\n              ment for the -o option to the set builtin command (see SHELL  BUILTIN  COMMANDS  below).\n              The options appearing in SHELLOPTS are those reported as on by set -o.  If this variable\n              is in the environment when bash starts up, each shell option in the list will be enabled\n              before reading any startup files.  This variable is read-only.\n       SHLVL  Incremented by one each time an instance of bash is started.\n       SRANDOM\n              This  variable  expands to a 32-bit pseudo-random number each time it is referenced. The\n              random number generator is not linear on systems that support /dev/urandom  or  arc4ran‐\n              dom,  so each returned number has no relationship to the numbers preceding it.  The ran‐\n              dom number generator cannot be seeded, so assignments to this variable have  no  effect.\n              If SRANDOM is unset, it loses its special properties, even if it is subsequently reset.\n       UID    Expands to the user ID of the current user, initialized at shell startup.  This variable\n              is readonly.\n\n       The following variables are used by the shell.  In some cases, bash assigns a default value  to\n       a variable; these cases are noted below.\n\n       BASH_COMPAT\n              The  value is used to set the shell\'s compatibility level.  See SHELL COMPATIBILITY MODE\n              below for a description of the various compatibility  levels  and  their  effects.   The\n              value  may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the\n              desired compatibility level.  If BASH_COMPAT is unset or set to the  empty  string,  the\n              compatibility  level  is  set to the default for the current version.  If BASH_COMPAT is\n              set to a value that is not one of the valid compatibility levels, the  shell  prints  an\n              error  message  and sets the compatibility level to the default for the current version.\n              The valid values correspond to the compatibility levels described below under BSHELLCOM‐\n              PATIBILITYMODE.   For  example,  4.2 and 42 are valid values that correspond to the com‐\n              pat42 shopt option and set the compatibility level to 42.  The current version is also a\n              valid value.\n       BASH_ENV\n              If this parameter is set when bash is executing a shell script, its value is interpreted\n              as a filename containing commands to initialize the shell, as in ~/.bashrc.   The  value\n              of  BASH_ENV  is  subjected to parameter expansion, command substitution, and arithmetic\n              expansion before being interpreted as a filename.  PATH is not used to  search  for  the\n              resultant filename.\n       BASH_XTRACEFD\n              If set to an integer corresponding to a valid file descriptor, bash will write the trace\n              output generated when set -x is enabled to that file descriptor.  The file descriptor is\n              closed  when BASH_XTRACEFD is unset or assigned a new value.  Unsetting BASH_XTRACEFD or\n              assigning it the empty string causes the trace output to be sent to the standard  error.\n              Note  that  setting BASH_XTRACEFD to 2 (the standard error file descriptor) and then un‐\n              setting it will result in the standard error being closed.\n       CDPATH The search path for the cd command.  This is a colon-separated list  of  directories  in\n              which the shell looks for destination directories specified by the cd command.  A sample\n              value is ".:~:/usr".\n       CHILD_MAX\n              Set the number of exited child status values for the shell to remember.  Bash  will  not\n              allow  this value to be decreased below a POSIX-mandated minimum, and there is a maximum\n              value (currently 8192) that this may not exceed.  The minimum value is system-dependent.\n       COLUMNS\n              Used by the select compound command to determine the terminal width when printing selec‐\n              tion  lists.   Automatically set if the checkwinsize option is enabled or in an interac‐\n              tive shell upon receipt of a SIGWINCH.\n       COMPREPLY\n              An array variable from which bash reads the possible completions generated  by  a  shell\n              function  invoked  by  the programmable completion facility (see Programmable Completion\n              below).  Each array element contains one possible completion.\n       EMACS  If bash finds this variable in the environment when the shell starts with value "t",  it\n              assumes that the shell is running in an Emacs shell buffer and disables line editing.\n       ENV    Expanded  and  executed similarly to BASH_ENV (see INVOCATION above) when an interactive\n              shell is invoked in posix mode.\n       EXECIGNORE\n              A colon-separated list of shell patterns (see Pattern Matching)  defining  the  list  of\n              filenames  to be ignored by command search using PATH.  Files whose full pathnames match\n              one of these patterns are not considered executable files for the purposes of completion\n              and  command  execution  via  PATH  lookup.  This does not affect the behavior of the [,\n              test, and [[ commands.  Full pathnames in the command hash table are not subject to EXE‐\n              CIGNORE.   Use this variable to ignore shared library files that have the executable bit\n              set, but are not executable files.  The pattern matching honors the setting of the  ext‐\n              glob shell option.\n       FCEDIT The default editor for the fc builtin command.\n       FIGNORE\n              A  colon-separated  list  of suffixes to ignore when performing filename completion (see\n              READLINE below).  A filename whose suffix matches one of the entries in FIGNORE  is  ex‐\n              cluded  from the list of matched filenames.  A sample value is ".o:~" (Quoting is needed\n              when assigning a value to this variable, which contains tildes).\n       FUNCNEST\n              If set to a numeric value greater than 0, defines  a  maximum  function  nesting  level.\n              Function  invocations  that  exceed this nesting level will cause the current command to\n              abort.\n       GLOBIGNORE\n              A colon-separated list of patterns defining the set of file names to be ignored by path‐\n              name expansion.  If a file name matched by a pathname expansion pattern also matches one\n              of the patterns in GLOBIGNORE, it is removed from the list of matches.\n       HISTCONTROL\n              A colon-separated list of values controlling how commands are saved on the history list.\n              If the list of values includes ignorespace, lines which begin with a space character are\n              not saved in the history list.  A value of ignoredups causes lines matching the previous\n              history  entry  to not be saved.  A value of ignoreboth is shorthand for ignorespace and\n              ignoredups.  A value of erasedups causes all previous lines matching the current line to\n              be  removed from the history list before that line is saved.  Any value not in the above\n              list is ignored.  If HISTCONTROL is unset, or does not include a valid value, all  lines\n              read  by the shell parser are saved on the history list, subject to the value of HISTIG‐\n              NORE.  The second and subsequent lines of a multi-line compound command are not  tested,\n              and are added to the history regardless of the value of HISTCONTROL.\n       HISTFILE\n              The name of the file in which command history is saved (see HISTORY below).  The default\n              value is ~/.bash_history.  If unset, the command history is not saved when a  shell  ex‐\n              its.\n       HISTFILESIZE\n              The  maximum  number  of lines contained in the history file.  When this variable is as‐\n              signed a value, the history file is truncated, if necessary, to  contain  no  more  than\n              that number of lines by removing the oldest entries.  The history file is also truncated\n              to this size after writing it when a shell exits.  If the value is 0, the  history  file\n              is truncated to zero size.  Non-numeric values and numeric values less than zero inhibit\n              truncation.  The shell sets the default value to the value of HISTSIZE after reading any\n              startup files.\n       HISTIGNORE\n              A colon-separated list of patterns used to decide which command lines should be saved on\n              the history list.\n\nSummarize bash in 2 sentences.<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n', params: SamplingParams(n=1, presence_penalty=0.0, frequency_penalty=0.0, repetition_penalty=1.0, temperature=0.7, top_p=0.9, top_k=0, min_p=0.0, seed=None, stop=[], stop_token_ids=[], bad_words=[], include_stop_str_in_output=False, ignore_eos=False, max_tokens=998, min_tokens=0, logprobs=None, prompt_logprobs=None, skip_special_tokens=True, spaces_between_special_tokens=True, truncate_prompt_tokens=None, guided_decoding=None, extra_args=None), prompt_token_ids: None, prompt_embeds shape: None, lora_request: None, prompt_adapter_request: None.
INFO:     127.0.0.1:56000 - "POST /v1/chat/completions HTTP/1.1" 200 OK
INFO 06-15 14:54:57 [async_llm.py:261] Added request chatcmpl-0e66b941b5794f36b1fcc3833574dcff.
INFO 06-15 14:54:59 [logger.py:42] Received request chatcmpl-99b1713900ac41e19de798561be81c1d: prompt: '<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 26 Jul 2024\n\n<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nBASH(1)                                 General Commands Manual                                BASH(1)\n\nNAME\n       bash - GNU Bourne-Again SHell\n\nSYNOPSIS\n       bash [options] [command_string | file]\n\nCOPYRIGHT\n       Bash is Copyright (C) 1989-2020 by the Free Software Foundation, Inc.\n\nDESCRIPTION\n       Bash  is  an  sh-compatible  command  language interpreter that executes commands read from the\n       standard input or from a file.  Bash also incorporates useful features  from  the  Korn  and  C\n       shells (ksh and csh).\n\n       Bash  is  intended  to be a conformant implementation of the Shell and Utilities portion of the\n       IEEE POSIX specification (IEEE Standard 1003.1).  Bash can be configured to be POSIX-conformant\n       by default.\n\nOPTIONS\n       All of the single-character shell options documented in the description of the set builtin com‐\n       mand, including -o, can be used as options when the shell is invoked.  In addition, bash inter‐\n       prets the following options when it is invoked:\n\n       -c        If  the  -c option is present, then commands are read from the first non-option argu‐\n                 ment command_string.  If there are arguments after the command_string, the first  ar‐\n                 gument  is  assigned to $0 and any remaining arguments are assigned to the positional\n                 parameters.  The assignment to $0 sets the name of the shell, which is used in  warn‐\n                 ing and error messages.\n       -i        If the -i option is present, the shell is interactive.\n       -l        Make bash act as if it had been invoked as a login shell (see INVOCATION below).\n       -r        If  the  -r option is present, the shell becomes restricted (see RESTRICTED SHELL be‐\n                 low).\n       -s        If the -s option is present, or if no arguments remain after option processing,  then\n                 commands are read from the standard input.  This option allows the positional parame‐\n                 ters to be set when invoking an interactive shell or when  reading  input  through  a\n                 pipe.\n       -v        Print shell input lines as they are read.\n       -x        Print commands and their arguments as they are executed.\n       -D        A  list of all double-quoted strings preceded by $ is printed on the standard output.\n                 These are the strings that are subject to language translation when the  current  lo‐\n                 cale is not C or POSIX.  This implies the -n option; no commands will be executed.\n       [-+]O [shopt_option]\n                 shopt_option  is  one  of  the shell options accepted by the shopt builtin (see SHELL\n                 BUILTIN COMMANDS below).  If shopt_option is present, -O sets the value of  that  op‐\n                 tion;  +O  unsets  it.   If shopt_option is not supplied, the names and values of the\n                 shell options accepted by shopt are printed on the standard output.  If  the  invoca‐\n                 tion option is +O, the output is displayed in a format that may be reused as input.\n       --        A  --  signals  the end of options and disables further option processing.  Any argu‐\n                 ments after the -- are treated as filenames and  arguments.   An  argument  of  -  is\n                 equivalent to --.\n\n       Bash  also  interprets  a  number of multi-character options.  These options must appear on the\n       command line before the single-character options to be recognized.\n\n       --debugger\n              Arrange for the debugger profile to be executed before the shell starts.  Turns  on  ex‐\n              tended  debugging  mode (see the description of the extdebug option to the shopt builtin\n              below).\n       --dump-po-strings\n              Equivalent to -D, but the output is in the GNU gettext po (portable object) file format.\n       --dump-strings\n              Equivalent to -D.\n       --help Display a usage message on standard output and exit successfully.\n       --init-file file\n       --rcfile file\n              Execute  commands  from  file  instead  of   the   system   wide   initialization   file\n              /etc/bash.bashrc and the standard personal initialization file ~/.bashrc if the shell is\n              interactive (see INVOCATION below).\n\n       --login\n              Equivalent to -l.\n\n       --noediting\n              Do not use the GNU readline library to read command lines when the shell is interactive.\n\n       --noprofile\n              Do not read either the system-wide startup file /etc/profile or any of the personal ini‐\n              tialization files ~/.bash_profile, ~/.bash_login, or ~/.profile.  By default, bash reads\n              these files when it is invoked as a login shell (see INVOCATION below).\n\n       --norc Do not read and execute the system wide initialization  file  /etc/bash.bashrc  and  the\n              personal  initialization  file ~/.bashrc if the shell is interactive.  This option is on\n              by default if the shell is invoked as sh.\n\n       --posix\n              Change the behavior of bash where the default operation differs from the POSIX  standard\n              to  match  the  standard (posix mode).  See SEE ALSO below for a reference to a document\n              that details how posix mode affects bash\'s behavior.\n\n       --restricted\n              The shell becomes restricted (see RESTRICTED SHELL below).\n\n       --verbose\n              Equivalent to -v.\n\n       --version\n              Show version information for this instance of bash on the standard output and exit  suc‐\n              cessfully.\n\nARGUMENTS\n       If arguments remain after option processing, and neither the -c nor the -s option has been sup‐\n       plied, the first argument is assumed to be the name of a file containing  shell  commands.   If\n       bash  is invoked in this fashion, $0 is set to the name of the file, and the positional parame‐\n       ters are set to the remaining arguments.  Bash reads and executes commands from this file, then\n       exits.   Bash\'s  exit status is the exit status of the last command executed in the script.  If\n       no commands are executed, the exit status is 0.  An attempt is first made to open the  file  in\n       the  current  directory,  and,  if no file is found, then the shell searches the directories in\n       PATH for the script.\n\nINVOCATION\n       A login shell is one whose first character of argument zero is a -, or  one  started  with  the\n       --login option.\n\n       An  interactive  shell is one started without non-option arguments (unless -s is specified) and\n       without the -c option whose standard input and error are both connected to terminals (as deter‐\n       mined  by  isatty(3)), or one started with the -i option.  PS1 is set and $- includes i if bash\n       is interactive, allowing a shell script or a startup file to test this state.\n\n       The following paragraphs describe how bash executes its startup files.  If any of the files ex‐\n       ist  but  cannot be read, bash reports an error.  Tildes are expanded in filenames as described\n       below under Tilde Expansion in the EXPANSION section.\n\n       When bash is invoked as an interactive login shell, or as  a  non-interactive  shell  with  the\n       --login  option,  it first reads and executes commands from the file /etc/profile, if that file\n       exists.  After reading that file, it looks for ~/.bash_profile, ~/.bash_login, and  ~/.profile,\n       in  that order, and reads and executes commands from the first one that exists and is readable.\n       The --noprofile option may be used when the shell is started to inhibit this behavior.\n\n       When an interactive login shell exits, or a  non-interactive  login  shell  executes  the  exit\n       builtin command, bash reads and executes commands from the file ~/.bash_logout, if it exists.\n\n       When  an  interactive  shell that is not a login shell is started, bash reads and executes com‐\n       mands from /etc/bash.bashrc and ~/.bashrc, if these files exist.  This may be inhibited by  us‐\n       ing  the  --norc option.  The --rcfile file option will force bash to read and execute commands\n       from file instead of /etc/bash.bashrc and ~/.bashrc.\n\n       When bash is started non-interactively, to run a shell script, for example, it  looks  for  the\n       variable  BASH_ENV  in the environment, expands its value if it appears there, and uses the ex‐\n       panded value as the name of a file to read and execute.  Bash behaves as if the following  com‐\n       mand were executed:\n              if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\n       but the value of the PATH variable is not used to search for the filename.\n\n       If  bash is invoked with the name sh, it tries to mimic the startup behavior of historical ver‐\n       sions of sh as closely as possible, while conforming to the POSIX standard as well.   When  in‐\n       voked  as  an  interactive  login shell, or a non-interactive shell with the --login option, it\n       first attempts to read and execute commands from /etc/profile and ~/.profile,  in  that  order.\n       The  --noprofile  option  may be used to inhibit this behavior.  When invoked as an interactive\n       shell with the name sh, bash looks for the variable ENV, expands its value if  it  is  defined,\n       and  uses  the expanded value as the name of a file to read and execute.  Since a shell invoked\n       as sh does not attempt to read and execute commands from any other startup files, the  --rcfile\n       option  has  no  effect.   A non-interactive shell invoked with the name sh does not attempt to\n       read any other startup files.  When invoked as sh, bash enters posix  mode  after  the  startup\n       files are read.\n\n       When  bash  is  started  in posix mode, as with the --posix command line option, it follows the\n       POSIX standard for startup files.  In this mode, interactive shells expand the ENV variable and\n       commands  are  read  and  executed  from  the  file whose name is the expanded value.  No other\n       startup files are read.\n\n       Bash attempts to determine when it is being run with its standard input connected to a  network\n       connection, as when executed by the remote shell daemon, usually rshd, or the secure shell dae‐\n       mon sshd.  If bash determines it is being run in this fashion, it reads and  executes  commands\n       from  ~/.bashrc  and  ~/.bashrc, if these files exist and are readable.  It will not do this if\n       invoked as sh.  The --norc option may be used to inhibit this behavior, and the --rcfile option\n       may  be  used  to force another file to be read, but neither rshd nor sshd generally invoke the\n       shell with those options or allow them to be specified.\n\n       If the shell is started with the effective user (group) id not equal to the real  user  (group)\n       id,  and  the -p option is not supplied, no startup files are read, shell functions are not in‐\n       herited from the environment, the SHELLOPTS, BASHOPTS, CDPATH,  and  GLOBIGNORE  variables,  if\n       they  appear in the environment, are ignored, and the effective user id is set to the real user\n       id.  If the -p option is supplied at invocation, the startup behavior is the same, but the  ef‐\n       fective user id is not reset.\n\nDEFINITIONS\n       The following definitions are used throughout the rest of this document.\n       blank  A space or tab.\n       word   A  sequence of characters considered as a single unit by the shell.  Also known as a to‐\n              ken.\n       name   A word consisting only of alphanumeric characters and underscores, and beginning with an\n              alphabetic character or an underscore.  Also referred to as an identifier.\n       metacharacter\n              A character that, when unquoted, separates words.  One of the following:\n              |  & ; ( ) < > space tab newline\n       control operator\n              A token that performs a control function.  It is one of the following symbols:\n              || & && ; ;; ;& ;;& ( ) | |& <newline>\n\nRESERVED WORDS\n       Reserved  words  are  words  that have a special meaning to the shell.  The following words are\n       recognized as reserved when unquoted and either the first word of a command (see SHELL  GRAMMAR\n       below),  the  third word of a case or select command (only in is valid), or the third word of a\n       for command (only in and do are valid):\n\n       ! case  coproc  do done elif else esac fi for function if in select then until while {  }  time\n       [[ ]]\n\nSHELL GRAMMAR\n   Simple Commands\n       A  simple  command  is  a sequence of optional variable assignments followed by blank-separated\n       words and redirections, and terminated by a control operator.  The  first  word  specifies  the\n       command  to be executed, and is passed as argument zero.  The remaining words are passed as ar‐\n       guments to the invoked command.\n\n       The return value of a simple command is its exit status, or 128+n if the command is  terminated\n       by signal n.\n\n   Pipelines\n       A pipeline is a sequence of one or more commands separated by one of the control operators | or\n       |&.  The format for a pipeline is:\n\n              [time [-p]] [ ! ] command [ [|⎪|&] command2 ... ]\n\n       The standard output of command is connected via a pipe to the standard input of command2.  This\n       connection  is  performed before any redirections specified by the command (see REDIRECTION be‐\n       low).  If |& is used, command\'s standard error, in addition to its  standard  output,  is  con‐\n       nected  to  command2\'s  standard  input through the pipe; it is shorthand for 2>&1 |.  This im‐\n       plicit redirection of the standard error to the standard output is performed after any redirec‐\n       tions specified by the command.\n\n       The return status of a pipeline is the exit status of the last command, unless the pipefail op‐\n       tion is enabled.  If pipefail is enabled, the pipeline\'s return status is the value of the last\n       (rightmost)  command to exit with a non-zero status, or zero if all commands exit successfully.\n       If the reserved word !  precedes a pipeline, the exit status of that pipeline  is  the  logical\n       negation  of the exit status as described above.  The shell waits for all commands in the pipe‐\n       line to terminate before returning a value.\n\n       If the time reserved word precedes a pipeline, the elapsed as well as user and system time con‐\n       sumed  by  its  execution are reported when the pipeline terminates.  The -p option changes the\n       output format to that specified by POSIX.  When the shell is in posix mode, it does not  recog‐\n       nize  time as a reserved word if the next token begins with a `-\'.  The TIMEFORMAT variable may\n       be set to a format string that specifies how the timing information should  be  displayed;  see\n       the description of TIMEFORMAT under Shell Variables below.\n\n       When  the  shell  is in posix mode, time may be followed by a newline.  In this case, the shell\n       displays the total user and system time consumed by the shell and its children.  The TIMEFORMAT\n       variable may be used to specify the format of the time information.\n\n       Each  command  in a pipeline is executed as a separate process (i.e., in a subshell).  See COM‐\n       MAND EXECUTION ENVIRONMENT for a description of a subshell environment.  If the lastpipe option\n       is  enabled using the shopt builtin (see the description of shopt below), the last element of a\n       pipeline may be run by the shell process.\n\n   Lists\n       A list is a sequence of one or more pipelines separated by one of the operators ;,  &,  &&,  or\n       ||, and optionally terminated by one of ;, &, or <newline>.\n\n       Of these list operators, && and || have equal precedence, followed by ; and &, which have equal\n       precedence.\n\n       A sequence of one or more newlines may appear in a list instead of a semicolon to delimit  com‐\n       mands.\n\n       If  a  command  is  terminated by the control operator &, the shell executes the command in the\n       background in a subshell.  The shell does not wait for the command to finish,  and  the  return\n       status  is  0.   These are referred to as asynchronous commands.  Commands separated by a ; are\n       executed sequentially; the shell waits for each command to terminate in turn.  The return  sta‐\n       tus is the exit status of the last command executed.\n\n       AND  and OR lists are sequences of one or more pipelines separated by the && and || control op‐\n       erators, respectively.  AND and OR lists are executed with left associativity.  An AND list has\n       the form\n\n              command1 && command2\n\n       command2 is executed if, and only if, command1 returns an exit status of zero (success).\n\n       An OR list has the form\n\n              command1 || command2\n\n       command2 is executed if, and only if, command1 returns a non-zero exit status.  The return sta‐\n       tus of AND and OR lists is the exit status of the last command executed in the list.\n\n   Compound Commands\n       A compound command is one of the following.  In most cases a list in  a  command\'s  description\n       may be separated from the rest of the command by one or more newlines, and may be followed by a\n       newline in place of a semicolon.\n\n       (list) list is executed in a subshell environment (see COMMAND  EXECUTION  ENVIRONMENT  below).\n              Variable assignments and builtin commands that affect the shell\'s environment do not re‐\n              main in effect after the command completes.  The return status is  the  exit  status  of\n              list.\n\n       { list; }\n              list  is simply executed in the current shell environment.  list must be terminated with\n              a newline or semicolon.  This is known as a group command.  The  return  status  is  the\n              exit  status of list.  Note that unlike the metacharacters ( and ), { and } are reserved\n              words and must occur where a reserved word is permitted to be recognized.  Since they do\n              not  cause a word break, they must be separated from list by whitespace or another shell\n              metacharacter.\n\n       ((expression))\n              The expression is evaluated according to the  rules  described  below  under  ARITHMETIC\n              EVALUATION.   If the value of the expression is non-zero, the return status is 0; other‐\n              wise the return status is 1.  This is exactly equivalent to let "expression".\n\n       [[ expression ]]\n              Return a status of 0 or 1 depending on the evaluation of the conditional expression  ex‐\n              pression.   Expressions  are composed of the primaries described below under CONDITIONAL\n              EXPRESSIONS.  Word splitting and pathname expansion are not performed on the  words  be‐\n              tween  the  [[ and ]]; tilde expansion, parameter and variable expansion, arithmetic ex‐\n              pansion, command substitution, process substitution, and quote  removal  are  performed.\n              Conditional operators such as -f must be unquoted to be recognized as primaries.\n\n              When  used  with  [[, the < and > operators sort lexicographically using the current lo‐\n              cale.\n\n       See the description of the test builtin command (section SHELL BUILTIN COMMANDS below) for  the\n       handling of parameters (i.e.  missing parameters).\n\n       When  the == and != operators are used, the string to the right of the operator is considered a\n       pattern and matched according to the rules described below under Pattern Matching,  as  if  the\n       extglob  shell  option  were  enabled.  The = operator is equivalent to ==.  If the nocasematch\n       shell option is enabled, the match is performed without regard to the case of alphabetic  char‐\n       acters.   The  return value is 0 if the string matches (==) or does not match (!=) the pattern,\n       and 1 otherwise.  Any part of the pattern may be quoted to  force  the  quoted  portion  to  be\n       matched as a string.\n\n       An  additional  binary operator, =~, is available, with the same precedence as == and !=.  When\n       it is used, the string to the right of the operator is considered a POSIX extended regular  ex‐\n       pression  and  matched  accordingly (using the POSIX regcomp and regexec interfaces usually de‐\n       scribed in regex(3)).  The return value is 0 if the string matches the pattern,  and  1  other‐\n       wise.   If  the regular expression is syntactically incorrect, the conditional expression\'s re‐\n       turn value is 2.  If the nocasematch shell option is enabled, the match  is  performed  without\n       regard  to  the  case of alphabetic characters.  Any part of the pattern may be quoted to force\n       the quoted portion to be matched as a string.  Bracket expressions in regular expressions  must\n       be treated carefully, since normal quoting characters lose their meanings between brackets.  If\n       the pattern is stored in a shell variable, quoting the variable  expansion  forces  the  entire\n       pattern to be matched as a string.\n\n       The  pattern  will  match if it matches any part of the string.  Anchor the pattern using the ^\n       and $ regular expression operators to force it to match the entire string.  The array  variable\n       BASH_REMATCH  records  which  parts of the string matched the pattern.  The element of BASH_RE‐\n       MATCH with index 0 contains the portion of the string matching the entire  regular  expression.\n       Substrings  matched  by parenthesized subexpressions within the regular expression are saved in\n       the remaining BASH_REMATCH indices. The element of BASH_REMATCH with index n is the portion  of\n       the string matching the nth parenthesized subexpression.\n\n       Expressions may be combined using the following operators, listed in decreasing order of prece‐\n       dence:\n\n              ( expression )\n                     Returns the value of expression.  This may be used to override the normal  prece‐\n                     dence of operators.\n              ! expression\n                     True if expression is false.\n              expression1 && expression2\n                     True if both expression1 and expression2 are true.\n              expression1 || expression2\n                     True if either expression1 or expression2 is true.\n\n              The  && and || operators do not evaluate expression2 if the value of expression1 is suf‐\n              ficient to determine the return value of the entire conditional expression.\n\n       for name [ [ in [ word ... ] ] ; ] do list ; done\n              The list of words following in is expanded, generating a list of  items.   The  variable\n              name  is  set  to each element of this list in turn, and list is executed each time.  If\n              the in word is omitted, the for command executes list once for each positional parameter\n              that  is  set  (see PARAMETERS below).  The return status is the exit status of the last\n              command that executes.  If the expansion of the items following in results in  an  empty\n              list, no commands are executed, and the return status is 0.\n\n       for (( expr1 ; expr2 ; expr3 )) ; do list ; done\n              First, the arithmetic expression expr1 is evaluated according to the rules described be‐\n              low under ARITHMETIC EVALUATION.  The arithmetic expression expr2 is then evaluated  re‐\n              peatedly  until  it  evaluates  to zero.  Each time expr2 evaluates to a non-zero value,\n              list is executed and the arithmetic expression expr3 is evaluated.  If any expression is\n              omitted, it behaves as if it evaluates to 1.  The return value is the exit status of the\n              last command in list that is executed, or false if any of the expressions is invalid.\n\n       select name [ in word ] ; do list ; done\n              The list of words following in is expanded, generating a list of items.  The set of  ex‐\n              panded  words  is  printed  on the standard error, each preceded by a number.  If the in\n              word is omitted, the positional parameters are printed (see PARAMETERS below).  The  PS3\n              prompt  is then displayed and a line read from the standard input.  If the line consists\n              of a number corresponding to one of the displayed words, then the value of name  is  set\n              to  that  word.  If the line is empty, the words and prompt are displayed again.  If EOF\n              is read, the command completes.  Any other value read causes name to  be  set  to  null.\n              The line read is saved in the variable REPLY.  The list is executed after each selection\n              until a break command is executed.  The exit status of select is the exit status of  the\n              last command executed in list, or zero if no commands were executed.\n\n       case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n              A  case  command first expands word, and tries to match it against each pattern in turn,\n              using the matching rules described under Pattern Matching below.  The word  is  expanded\n              using  tilde  expansion, parameter and variable expansion, arithmetic expansion, command\n              substitution, process substitution and quote removal.  Each pattern examined is expanded\n              using  tilde  expansion, parameter and variable expansion, arithmetic expansion, command\n              substitution, and process substitution.  If the nocasematch shell option is enabled, the\n              match is performed without regard to the case of alphabetic characters.  When a match is\n              found, the corresponding list is executed.  If the ;; operator is  used,  no  subsequent\n              matches are attempted after the first pattern match.  Using ;& in place of ;; causes ex‐\n              ecution to continue with the list associated with the next set of patterns.   Using  ;;&\n              in  place of ;; causes the shell to test the next pattern list in the statement, if any,\n              and execute any associated list on a successful match, continuing the case statement ex‐\n              ecution  as  if the pattern list had not matched.  The exit status is zero if no pattern\n              matches.  Otherwise, it is the exit status of the last command executed in list.\n\n       if list; then list; [ elif list; then list; ] ... [ else list; ] fi\n              The if list is executed.  If its exit status is zero, the then list is executed.  Other‐\n              wise,  each  elif  list  is executed in turn, and if its exit status is zero, the corre‐\n              sponding then list is executed and the command completes.  Otherwise, the else  list  is\n              executed,  if present.  The exit status is the exit status of the last command executed,\n              or zero if no condition tested true.\n\n       while list-1; do list-2; done\n       until list-1; do list-2; done\n              The while command continuously executes the list list-2 as long as the last  command  in\n              the  list  list-1 returns an exit status of zero.  The until command is identical to the\n              while command, except that the test is negated: list-2 is executed as long as  the  last\n              command  in list-1 returns a non-zero exit status.  The exit status of the while and un‐\n              til commands is the exit status of the last command executed in list-2, or zero if  none\n              was executed.\n\n   Coprocesses\n       A  coprocess  is a shell command preceded by the coproc reserved word.  A coprocess is executed\n       asynchronously in a subshell, as if the command had been terminated with the &  control  opera‐\n       tor, with a two-way pipe established between the executing shell and the coprocess.\n\n       The format for a coprocess is:\n\n              coproc [NAME] command [redirections]\n\n       This  creates  a  coprocess  named  NAME.  If NAME is not supplied, the default name is COPROC.\n       NAME must not be supplied if command is a simple command (see above); otherwise, it  is  inter‐\n       preted as the first word of the simple command.  When the coprocess is executed, the shell cre‐\n       ates an array variable (see Arrays below) named NAME in the context  of  the  executing  shell.\n       The  standard  output  of command is connected via a pipe to a file descriptor in the executing\n       shell, and that file descriptor is assigned to NAME[0].  The standard input of command is  con‐\n       nected  via a pipe to a file descriptor in the executing shell, and that file descriptor is as‐\n       signed to NAME[1].  This pipe is established before any redirections specified by  the  command\n       (see  REDIRECTION  below).  The file descriptors can be utilized as arguments to shell commands\n       and redirections using standard word expansions.  Other than those created to  execute  command\n       and process substitutions, the file descriptors are not available in subshells.  The process ID\n       of the shell spawned to execute the coprocess  is  available  as  the  value  of  the  variable\n       NAME_PID.  The wait builtin command may be used to wait for the coprocess to terminate.\n\n       Since  the  coprocess  is created as an asynchronous command, the coproc command always returns\n       success.  The return status of a coprocess is the exit status of command.\n\n   Shell Function Definitions\n       A shell function is an object that is called like a simple command and executes a compound com‐\n       mand with a new set of positional parameters.  Shell functions are declared as follows:\n\n       fname () compound-command [redirection]\n       function fname [()] compound-command [redirection]\n              This  defines  a  function named fname.  The reserved word function is optional.  If the\n              function reserved word is supplied, the parentheses are optional.  The body of the func‐\n              tion  is the compound command compound-command (see Compound Commands above).  That com‐\n              mand is usually a list of commands between { and }, but may be any command listed  under\n              Compound  Commands above, with one exception: If the function reserved word is used, but\n              the parentheses are not supplied, the braces are required.  compound-command is executed\n              whenever  fname is specified as the name of a simple command.  When in posix mode, fname\n              must be a valid shell name and may not be the name of one of the POSIX special builtins.\n              In default mode, a function name can be any unquoted shell word that does not contain $.\n              Any redirections (see REDIRECTION below) specified when a function is defined  are  per‐\n              formed  when the function is executed.  The exit status of a function definition is zero\n              unless a syntax error occurs or a readonly function with the same name  already  exists.\n              When executed, the exit status of a function is the exit status of the last command exe‐\n              cuted in the body.  (See FUNCTIONS below.)\n\nCOMMENTS\n       In a non-interactive shell, or an interactive shell in which the interactive_comments option to\n       the shopt builtin is enabled (see SHELL BUILTIN COMMANDS below), a word beginning with # causes\n       that word and all remaining characters on that line to be ignored.  An interactive shell  with‐\n       out  the interactive_comments option enabled does not allow comments.  The interactive_comments\n       option is on by default in interactive shells.\n\nQUOTING\n       Quoting is used to remove the special meaning of certain characters  or  words  to  the  shell.\n       Quoting  can  be  used to disable special treatment for special characters, to prevent reserved\n       words from being recognized as such, and to prevent parameter expansion.\n\n       Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell  and\n       must be quoted if it is to represent itself.\n\n       When the command history expansion facilities are being used (see HISTORY EXPANSION below), the\n       history expansion character, usually !, must be quoted to prevent history expansion.\n\n       There are three quoting mechanisms: the escape character, single quotes, and double quotes.\n\n       A non-quoted backslash (\\) is the escape character.  It preserves the literal value of the next\n       character that follows, with the exception of <newline>.  If a \\<newline> pair appears, and the\n       backslash is not itself quoted, the \\<newline> is treated as a line continuation (that  is,  it\n       is removed from the input stream and effectively ignored).\n\n       Enclosing  characters in single quotes preserves the literal value of each character within the\n       quotes.  A single quote may not occur between single quotes, even when preceded by a backslash.\n\n       Enclosing characters in double quotes preserves the literal value of all characters within  the\n       quotes,  with  the  exception  of $, `, \\, and, when history expansion is enabled, !.  When the\n       shell is in posix mode, the ! has no special meaning within double quotes,  even  when  history\n       expansion  is  enabled.   The  characters  $  and  ` retain their special meaning within double\n       quotes.  The backslash retains its special meaning only when followed by one of  the  following\n       characters:  $,  `,  ",  \\, or <newline>.  A double quote may be quoted within double quotes by\n       preceding it with a backslash.  If enabled, history expansion will be  performed  unless  an  !\n       appearing in double quotes is escaped using a backslash.  The backslash preceding the !  is not\n       removed.\n\n       The special parameters * and @ have special meaning when in double quotes (see  PARAMETERS  be‐\n       low).\n\n       Words of the form $\'string\' are treated specially.  The word expands to string, with backslash-\n       escaped characters replaced as specified by the ANSI C standard.  Backslash  escape  sequences,\n       if present, are decoded as follows:\n              \\a     alert (bell)\n              \\b     backspace\n              \\e\n              \\E     an escape character\n              \\f     form feed\n              \\n     new line\n              \\r     carriage return\n              \\t     horizontal tab\n              \\v     vertical tab\n              \\\\     backslash\n              \\\'     single quote\n              \\"     double quote\n              \\?     question mark\n              \\nnn   the  eight-bit  character  whose value is the octal value nnn (one to three octal\n                     digits)\n              \\xHH   the eight-bit character whose value is the hexadecimal value HH (one or  two  hex\n                     digits)\n              \\uHHHH the  Unicode  (ISO/IEC 10646) character whose value is the hexadecimal value HHHH\n                     (one to four hex digits)\n              \\UHHHHHHHH\n                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHH‐\n                     HHH (one to eight hex digits)\n              \\cx    a control-x character\n\n       The expanded result is single-quoted, as if the dollar sign had not been present.\n\n       A double-quoted string preceded by a dollar sign ($"string") will cause the string to be trans‐\n       lated according to the current locale.  The gettext infrastructure performs the message catalog\n       lookup  and  translation, using the LC_MESSAGES and TEXTDOMAIN shell variables.  If the current\n       locale is C or POSIX, or if there are no translations available, the dollar  sign  is  ignored.\n       If the string is translated and replaced, the replacement is double-quoted.\n\nPARAMETERS\n       A parameter is an entity that stores values.  It can be a name, a number, or one of the special\n       characters listed below under Special Parameters.  A variable is a parameter denoted by a name.\n       A  variable has a value and zero or more attributes.  Attributes are assigned using the declare\n       builtin command (see declare below in SHELL BUILTIN COMMANDS).\n\n       A parameter is set if it has been assigned a value.  The null string is a valid value.  Once  a\n       variable  is  set,  it  may be unset only by using the unset builtin command (see SHELL BUILTIN\n       COMMANDS below).\n\n       A variable may be assigned to by a statement of the form\n\n              name=[value]\n\n       If value is not given, the variable is assigned the null string.  All values undergo tilde  ex‐\n       pansion,  parameter  and  variable  expansion,  command substitution, arithmetic expansion, and\n       quote removal (see EXPANSION below).  If the variable has its integer attribute set, then value\n       is evaluated as an arithmetic expression even if the $((...)) expansion is not used (see Arith‐\n       metic Expansion below).  Word splitting is not performed, with the exception  of  "$@"  as  ex‐\n       plained  below  under  Special  Parameters.   Pathname  expansion is not performed.  Assignment\n       statements may also appear as arguments to the alias, declare, typeset, export,  readonly,  and\n       local  builtin  commands (declaration commands).  When in posix mode, these builtins may appear\n       in a command after one or more instances of the command builtin  and  retain  these  assignment\n       statement properties.\n\n       In  the context where an assignment statement is assigning a value to a shell variable or array\n       index, the += operator can be used to append to or add to the variable\'s previous value.   This\n       includes  arguments to builtin commands such as declare that accept assignment statements (dec‐\n       laration commands).  When += is applied to a variable for which the integer attribute has  been\n       set,  value is evaluated as an arithmetic expression and added to the variable\'s current value,\n       which is also evaluated.  When += is applied to an array  variable  using  compound  assignment\n       (see  Arrays  below), the variable\'s value is not unset (as it is when using =), and new values\n       are appended to the array beginning at one greater than the array\'s maximum index (for  indexed\n       arrays)  or  added  as  additional  key-value pairs in an associative array.  When applied to a\n       string-valued variable, value is expanded and appended to the variable\'s value.\n\n       A variable can be assigned the nameref attribute using the -n option to the  declare  or  local\n       builtin  commands  (see  the descriptions of declare and local below) to create a nameref, or a\n       reference to another variable.  This allows variables to be manipulated  indirectly.   Whenever\n       the  nameref  variable is referenced, assigned to, unset, or has its attributes modified (other\n       than using or changing the nameref attribute itself), the operation is  actually  performed  on\n       the  variable  specified  by  the  nameref variable\'s value.  A nameref is commonly used within\n       shell functions to refer to a variable whose name is passed as an  argument  to  the  function.\n       For instance, if a variable name is passed to a shell function as its first argument, running\n              declare -n ref=$1\n       inside  the  function creates a nameref variable ref whose value is the variable name passed as\n       the first argument.  References and assignments to ref, and  changes  to  its  attributes,  are\n       treated  as references, assignments, and attribute modifications to the variable whose name was\n       passed as $1.  If the control variable in a for loop has the nameref  attribute,  the  list  of\n       words  can be a list of shell variables, and a name reference will be established for each word\n       in the list, in turn, when the loop is executed.  Array variables cannot be given  the  nameref\n       attribute.   However,  nameref  variables  can  reference array variables and subscripted array\n       variables.  Namerefs can be unset using the -n option to the unset builtin.  Otherwise, if  un‐\n       set  is executed with the name of a nameref variable as an argument, the variable referenced by\n       the nameref variable will be unset.\n\n   Positional Parameters\n       A positional parameter is a parameter denoted by one or more  digits,  other  than  the  single\n       digit 0.  Positional parameters are assigned from the shell\'s arguments when it is invoked, and\n       may be reassigned using the set builtin command.  Positional parameters may not be assigned  to\n       with  assignment  statements.   The positional parameters are temporarily replaced when a shell\n       function is executed (see FUNCTIONS below).\n\n       When a positional parameter consisting of more than a single digit is expanded, it must be  en‐\n       closed in braces (see EXPANSION below).\n\n   Special Parameters\n       The  shell  treats  several parameters specially.  These parameters may only be referenced; as‐\n       signment to them is not allowed.\n       *      Expands to the positional parameters, starting from one.   When  the  expansion  is  not\n              within double quotes, each positional parameter expands to a separate word.  In contexts\n              where it is performed, those words are subject to further word  splitting  and  pathname\n              expansion.   When the expansion occurs within double quotes, it expands to a single word\n              with the value of each parameter separated by the first character  of  the  IFS  special\n              variable.  That is, "$*" is equivalent to "$1c$2c...", where c is the first character of\n              the value of the IFS variable.  If IFS is unset, the parameters are separated by spaces.\n              If IFS is null, the parameters are joined without intervening separators.\n       @      Expands  to the positional parameters, starting from one.  In contexts where word split‐\n              ting is performed, this expands each positional parameter to a  separate  word;  if  not\n              within double quotes, these words are subject to word splitting.  In contexts where word\n              splitting is not performed, this expands to a single word with each positional parameter\n              separated  by  a  space.  When the expansion occurs within double quotes, each parameter\n              expands to a separate word.  That is, "$@" is equivalent to "$1" "$2" ...  If  the  dou‐\n              ble-quoted  expansion  occurs  within  a  word,  the expansion of the first parameter is\n              joined with the beginning part of the original word, and the expansion of the  last  pa‐\n              rameter is joined with the last part of the original word.  When there are no positional\n              parameters, "$@" and $@ expand to nothing (i.e., they are removed).\n       #      Expands to the number of positional parameters in decimal.\n       ?      Expands to the exit status of the most recently executed foreground pipeline.\n       -      Expands to the current option flags as specified upon invocation,  by  the  set  builtin\n              command, or those set by the shell itself (such as the -i option).\n       $      Expands  to the process ID of the shell.  In a () subshell, it expands to the process ID\n              of the current shell, not the subshell.\n       !      Expands to the process ID of the job most recently placed into the  background,  whether\n              executed as an asynchronous command or using the bg builtin (see JOB CONTROL below).\n       0      Expands  to the name of the shell or shell script.  This is set at shell initialization.\n              If bash is invoked with a file of commands, $0 is set to the name of that file.  If bash\n              is  started with the -c option, then $0 is set to the first argument after the string to\n              be executed, if one is present.  Otherwise, it is set to the  filename  used  to  invoke\n              bash, as given by argument zero.\n\n   Shell Variables\n       The following variables are set by the shell:\n\n       _      At shell startup, set to the pathname used to invoke the shell or shell script being ex‐\n              ecuted as passed in the environment or argument list.  Subsequently, expands to the last\n              argument  to  the  previous  simple command executed in the foreground, after expansion.\n              Also set to the full pathname used to invoke each command executed and placed in the en‐\n              vironment  exported  to that command.  When checking mail, this parameter holds the name\n              of the mail file currently being checked.\n       BASH   Expands to the full filename used to invoke this instance of bash.\n       BASHOPTS\n              A colon-separated list of enabled shell options.  Each word in the list is a valid argu‐\n              ment  for the -s option to the shopt builtin command (see SHELL BUILTIN COMMANDS below).\n              The options appearing in BASHOPTS are those reported as on by shopt.  If  this  variable\n              is in the environment when bash starts up, each shell option in the list will be enabled\n              before reading any startup files.  This variable is read-only.\n       BASHPID\n              Expands to the process ID of the current bash process.  This differs from $$ under  cer‐\n              tain  circumstances,  such  as  subshells that do not require bash to be re-initialized.\n              Assignments to BASHPID have no effect.  If BASHPID is unset, it loses its special  prop‐\n              erties, even if it is subsequently reset.\n       BASH_ALIASES\n              An  associative  array variable whose members correspond to the internal list of aliases\n              as maintained by the alias builtin.  Elements added to this array appear  in  the  alias\n              list;  however,  unsetting array elements currently does not cause aliases to be removed\n              from the alias list.  If BASH_ALIASES is unset, it loses its special properties, even if\n              it is subsequently reset.\n       BASH_ARGC\n              An array variable whose values are the number of parameters in each frame of the current\n              bash execution call stack.  The number of parameters to the  current  subroutine  (shell\n              function  or  script executed with . or source) is at the top of the stack.  When a sub‐\n              routine is executed, the number of parameters passed  is  pushed  onto  BASH_ARGC.   The\n              shell  sets  BASH_ARGC  only when in extended debugging mode (see the description of the\n              extdebug option to the shopt builtin below).   Setting  extdebug  after  the  shell  has\n              started  to execute a script, or referencing this variable when extdebug is not set, may\n              result in inconsistent values.\n       BASH_ARGV\n              An array variable containing all of the parameters in the current  bash  execution  call\n              stack.   The final parameter of the last subroutine call is at the top of the stack; the\n              first parameter of the initial call is at the bottom.  When a  subroutine  is  executed,\n              the  parameters  supplied are pushed onto BASH_ARGV.  The shell sets BASH_ARGV only when\n              in extended debugging mode (see the description of the  extdebug  option  to  the  shopt\n              builtin  below).   Setting  extdebug after the shell has started to execute a script, or\n              referencing this variable when extdebug is not set, may result in inconsistent values.\n       BASH_ARGV0\n              When referenced, this variable expands to the name of the shell or shell script (identi‐\n              cal  to $0; see the description of special parameter 0 above).  Assignment to BASH_ARGV0\n              causes the value assigned to also be assigned to $0.  If BASH_ARGV0 is unset,  it  loses\n              its special properties, even if it is subsequently reset.\n       BASH_CMDS\n              An  associative  array  variable  whose members correspond to the internal hash table of\n              commands as maintained by the hash builtin.  Elements added to this array appear in  the\n              hash  table; however, unsetting array elements currently does not cause command names to\n              be removed from the hash table.  If BASH_CMDS is unset, it loses its special properties,\n              even if it is subsequently reset.\n       BASH_COMMAND\n              The  command  currently being executed or about to be executed, unless the shell is exe‐\n              cuting a command as the result of a trap, in which case it is the command  executing  at\n              the  time  of the trap.  If BASH_COMMAND is unset, it loses its special properties, even\n              if it is subsequently reset.\n       BASH_EXECUTION_STRING\n              The command argument to the -c invocation option.\n       BASH_LINENO\n              An array variable whose members are the line numbers in source files where  each  corre‐\n              sponding  member  of FUNCNAME was invoked.  ${BASH_LINENO[$i]} is the line number in the\n              source   file   (${BASH_SOURCE[$i+1]})   where   ${FUNCNAME[$i]}    was    called    (or\n              ${BASH_LINENO[$i-1]} if referenced within another shell function).  Use LINENO to obtain\n              the current line number.\n       BASH_LOADABLES_PATH\n              A colon-separated list of directories in which the shell looks for dynamically  loadable\n              builtins specified by the enable command.\n       BASH_REMATCH\n              An  array variable whose members are assigned by the =~ binary operator to the [[ condi‐\n              tional command.  The element with index 0 is the portion of the string matching the  en‐\n              tire regular expression.  The element with index n is the portion of the string matching\n              the nth parenthesized subexpression.\n       BASH_SOURCE\n              An array variable whose members are the source filenames where the  corresponding  shell\n              function  names  in the FUNCNAME array variable are defined.  The shell function ${FUNC‐\n              NAME[$i]}   is   defined   in   the   file   ${BASH_SOURCE[$i]}    and    called    from\n              ${BASH_SOURCE[$i+1]}.\n       BASH_SUBSHELL\n              Incremented  by  one  within each subshell or subshell environment when the shell begins\n              executing in that environment.  The initial value is 0.  If BASH_SUBSHELL is  unset,  it\n              loses its special properties, even if it is subsequently reset.\n       BASH_VERSINFO\n              A  readonly  array  variable whose members hold version information for this instance of\n              bash.  The values assigned to the array members are as follows:\n              BASH_VERSINFO[0]        The major version number (the release).\n              BASH_VERSINFO[1]        The minor version number (the version).\n              BASH_VERSINFO[2]        The patch level.\n              BASH_VERSINFO[3]        The build version.\n              BASH_VERSINFO[4]        The release status (e.g., beta1).\n              BASH_VERSINFO[5]        The value of MACHTYPE.\n       BASH_VERSION\n              Expands to a string describing the version of this instance of bash.\n       COMP_CWORD\n              An index into ${COMP_WORDS} of the word containing the current  cursor  position.   This\n              variable is available only in shell functions invoked by the programmable completion fa‐\n              cilities (see Programmable Completion below).\n       COMP_KEY\n              The key (or final key of a key sequence) used to invoke the current completion function.\n       COMP_LINE\n              The current command line.  This variable is available only in shell functions and exter‐\n              nal commands invoked by the programmable completion facilities (see Programmable Comple‐\n              tion below).\n       COMP_POINT\n              The index of the current cursor position relative to the beginning of the  current  com‐\n              mand.  If the current cursor position is at the end of the current command, the value of\n              this variable is equal to ${#COMP_LINE}.  This variable is available only in shell func‐\n              tions  and external commands invoked by the programmable completion facilities (see Pro‐\n              grammable Completion below).\n       COMP_TYPE\n              Set to an integer value corresponding to the type of completion attempted that caused  a\n              completion function to be called: TAB, for normal completion, ?, for listing completions\n              after successive tabs, !, for listing alternatives on partial  word  completion,  @,  to\n              list  completions  if the word is not unmodified, or %, for menu completion.  This vari‐\n              able is available only in shell functions and external commands invoked by the  program‐\n              mable completion facilities (see Programmable Completion below).\n       COMP_WORDBREAKS\n              The  set of characters that the readline library treats as word separators when perform‐\n              ing word completion.  If COMP_WORDBREAKS is unset, it loses its special properties, even\n              if it is subsequently reset.\n       COMP_WORDS\n              An  array  variable (see Arrays below) consisting of the individual words in the current\n              command line.  The line is split into words as readline would split it, using COMP_WORD‐\n              BREAKS  as  described above.  This variable is available only in shell functions invoked\n              by the programmable completion facilities (see Programmable Completion below).\n       COPROC An array variable (see Arrays below) created to hold the  file  descriptors  for  output\n              from and input to an unnamed coprocess (see Coprocesses above).\n       DIRSTACK\n              An  array  variable  (see Arrays below) containing the current contents of the directory\n              stack.  Directories appear in the stack in the order they  are  displayed  by  the  dirs\n              builtin.   Assigning to members of this array variable may be used to modify directories\n              already in the stack, but the pushd and popd builtins must be used to add and remove di‐\n              rectories.   Assignment  to  this  variable  will  not change the current directory.  If\n              DIRSTACK is unset, it loses its special properties, even if it is subsequently reset.\n       EPOCHREALTIME\n              Each time this parameter is referenced, it expands to the number of  seconds  since  the\n              Unix  Epoch  (see time(3)) as a floating point value with micro-second granularity.  As‐\n              signments to EPOCHREALTIME are ignored.  If EPOCHREALTIME is unset, it loses its special\n              properties, even if it is subsequently reset.\n       EPOCHSECONDS\n              Each  time  this  parameter is referenced, it expands to the number of seconds since the\n              Unix Epoch (see time(3)).  Assignments to EPOCHSECONDS are ignored.  If EPOCHSECONDS  is\n              unset, it loses its special properties, even if it is subsequently reset.\n       EUID   Expands  to  the  effective  user  ID of the current user, initialized at shell startup.\n              This variable is readonly.\n       FUNCNAME\n              An array variable containing the names of all shell functions currently in the execution\n              call stack.  The element with index 0 is the name of any currently-executing shell func‐\n              tion.  The bottom-most element (the one with the highest index) is "main".   This  vari‐\n              able  exists  only  when a shell function is executing.  Assignments to FUNCNAME have no\n              effect.  If FUNCNAME is unset, it loses its special properties, even  if  it  is  subse‐\n              quently reset.\n\n              This  variable  can  be used with BASH_LINENO and BASH_SOURCE.  Each element of FUNCNAME\n              has corresponding elements in BASH_LINENO and BASH_SOURCE to describe  the  call  stack.\n              For instance, ${FUNCNAME[$i]} was called from the file ${BASH_SOURCE[$i+1]} at line num‐\n              ber ${BASH_LINENO[$i]}.  The caller builtin displays the current call stack  using  this\n              information.\n       GROUPS An  array  variable containing the list of groups of which the current user is a member.\n              Assignments to GROUPS have no effect.  If GROUPS is unset, it loses its special  proper‐\n              ties, even if it is subsequently reset.\n       HISTCMD\n              The  history  number, or index in the history list, of the current command.  Assignments\n              to HISTCMD are ignored.  If HISTCMD is unset, it loses its special properties,  even  if\n              it is subsequently reset.\n       HOSTNAME\n              Automatically set to the name of the current host.\n       HOSTTYPE\n              Automatically  set to a string that uniquely describes the type of machine on which bash\n              is executing.  The default is system-dependent.\n       LINENO Each time this parameter is referenced, the shell substitutes a  decimal  number  repre‐\n              senting  the  current  sequential line number (starting with 1) within a script or func‐\n              tion.  When not in a script or function, the value substituted is not guaranteed  to  be\n              meaningful.   If  LINENO is unset, it loses its special properties, even if it is subse‐\n              quently reset.\n       MACHTYPE\n              Automatically set to a string that fully describes the system type on which bash is exe‐\n              cuting, in the standard GNU cpu-company-system format.  The default is system-dependent.\n       MAPFILE\n              An  array  variable  (see  Arrays  below)  created  to hold the text read by the mapfile\n              builtin when no variable name is supplied.\n       OLDPWD The previous working directory as set by the cd command.\n       OPTARG The value of the last option argument processed by  the  getopts  builtin  command  (see\n              SHELL BUILTIN COMMANDS below).\n       OPTIND The index of the next argument to be processed by the getopts builtin command (see SHELL\n              BUILTIN COMMANDS below).\n       OSTYPE Automatically set to a string that describes the operating system on which bash is  exe‐\n              cuting.  The default is system-dependent.\n       PIPESTATUS\n              An  array  variable  (see Arrays below) containing a list of exit status values from the\n              processes in the most-recently-executed foreground pipeline (which may  contain  only  a\n              single command).\n       PPID   The process ID of the shell\'s parent.  This variable is readonly.\n       PWD    The current working directory as set by the cd command.\n       RANDOM Each  time  this  parameter  is referenced, it expands to a random integer between 0 and\n              32767.  Assigning a value to RANDOM initializes (seeds) the sequence of random  numbers.\n              If RANDOM is unset, it loses its special properties, even if it is subsequently reset.\n       READLINE_LINE\n              The contents of the readline line buffer, for use with "bind -x" (see SHELL BUILTIN COM‐\n              MANDS below).\n       READLINE_MARK\n              The position of the mark (saved insertion point) in the readline line  buffer,  for  use\n              with "bind -x" (see SHELL BUILTIN COMMANDS below).  The characters between the insertion\n              point and the mark are often called the region.\n       READLINE_POINT\n              The position of the insertion point in the readline line buffer, for use with "bind  -x"\n              (see SHELL BUILTIN COMMANDS below).\n       REPLY  Set  to  the  line  of input read by the read builtin command when no arguments are sup‐\n              plied.\n       SECONDS\n              Each time this parameter is referenced, the number of seconds since shell invocation  is\n              returned.   If a value is assigned to SECONDS, the value returned upon subsequent refer‐\n              ences is the number of seconds since the assignment plus the value assigned.  The number\n              of seconds at shell invocation and the current time is always determined by querying the\n              system clock.  If SECONDS is unset, it loses its special properties, even if it is  sub‐\n              sequently reset.\n       SHELLOPTS\n              A colon-separated list of enabled shell options.  Each word in the list is a valid argu‐\n              ment for the -o option to the set builtin command (see SHELL  BUILTIN  COMMANDS  below).\n              The options appearing in SHELLOPTS are those reported as on by set -o.  If this variable\n              is in the environment when bash starts up, each shell option in the list will be enabled\n              before reading any startup files.  This variable is read-only.\n       SHLVL  Incremented by one each time an instance of bash is started.\n       SRANDOM\n              This  variable  expands to a 32-bit pseudo-random number each time it is referenced. The\n              random number generator is not linear on systems that support /dev/urandom  or  arc4ran‐\n              dom,  so each returned number has no relationship to the numbers preceding it.  The ran‐\n              dom number generator cannot be seeded, so assignments to this variable have  no  effect.\n              If SRANDOM is unset, it loses its special properties, even if it is subsequently reset.\n       UID    Expands to the user ID of the current user, initialized at shell startup.  This variable\n              is readonly.\n\n       The following variables are used by the shell.  In some cases, bash assigns a default value  to\n       a variable; these cases are noted below.\n\n       BASH_COMPAT\n              The  value is used to set the shell\'s compatibility level.  See SHELL COMPATIBILITY MODE\n              below for a description of the various compatibility  levels  and  their  effects.   The\n              value  may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the\n              desired compatibility level.  If BASH_COMPAT is unset or set to the  empty  string,  the\n              compatibility  level  is  set to the default for the current version.  If BASH_COMPAT is\n              set to a value that is not one of the valid compatibility levels, the  shell  prints  an\n              error  message  and sets the compatibility level to the default for the current version.\n              The valid values correspond to the compatibility levels described below under BSHELLCOM‐\n              PATIBILITYMODE.   For  example,  4.2 and 42 are valid values that correspond to the com‐\n              pat42 shopt option and set the compatibility level to 42.  The current version is also a\n              valid value.\n       BASH_ENV\n              If this parameter is set when bash is executing a shell script, its value is interpreted\n              as a filename containing commands to initialize the shell, as in ~/.bashrc.   The  value\n              of  BASH_ENV  is  subjected to parameter expansion, command substitution, and arithmetic\n              expansion before being interpreted as a filename.  PATH is not used to  search  for  the\n              resultant filename.\n       BASH_XTRACEFD\n              If set to an integer corresponding to a valid file descriptor, bash will write the trace\n              output generated when set -x is enabled to that file descriptor.  The file descriptor is\n              closed  when BASH_XTRACEFD is unset or assigned a new value.  Unsetting BASH_XTRACEFD or\n              assigning it the empty string causes the trace output to be sent to the standard  error.\n              Note  that  setting BASH_XTRACEFD to 2 (the standard error file descriptor) and then un‐\n              setting it will result in the standard error being closed.\n       CDPATH The search path for the cd command.  This is a colon-separated list  of  directories  in\n              which the shell looks for destination directories specified by the cd command.  A sample\n              value is ".:~:/usr".\n       CHILD_MAX\n              Set the number of exited child status values for the shell to remember.  Bash  will  not\n              allow  this value to be decreased below a POSIX-mandated minimum, and there is a maximum\n              value (currently 8192) that this may not exceed.  The minimum value is system-dependent.\n       COLUMNS\n              Used by the select compound command to determine the terminal width when printing selec‐\n              tion  lists.   Automatically set if the checkwinsize option is enabled or in an interac‐\n              tive shell upon receipt of a SIGWINCH.\n       COMPREPLY\n              An array variable from which bash reads the possible completions generated  by  a  shell\n              function  invoked  by  the programmable completion facility (see Programmable Completion\n              below).  Each array element contains one possible completion.\n       EMACS  If bash finds this variable in the environment when the shell starts with value "t",  it\n              assumes that the shell is running in an Emacs shell buffer and disables line editing.\n       ENV    Expanded  and  executed similarly to BASH_ENV (see INVOCATION above) when an interactive\n              shell is invoked in posix mode.\n       EXECIGNORE\n              A colon-separated list of shell patterns (see Pattern Matching)  defining  the  list  of\n              filenames  to be ignored by command search using PATH.  Files whose full pathnames match\n              one of these patterns are not considered executable files for the purposes of completion\n              and  command  execution  via  PATH  lookup.  This does not affect the behavior of the [,\n              test, and [[ commands.  Full pathnames in the command hash table are not subject to EXE‐\n              CIGNORE.   Use this variable to ignore shared library files that have the executable bit\n              set, but are not executable files.  The pattern matching honors the setting of the  ext‐\n              glob shell option.\n       FCEDIT The default editor for the fc builtin command.\n       FIGNORE\n              A  colon-separated  list  of suffixes to ignore when performing filename completion (see\n              READLINE below).  A filename whose suffix matches one of the entries in FIGNORE  is  ex‐\n              cluded  from the list of matched filenames.  A sample value is ".o:~" (Quoting is needed\n              when assigning a value to this variable, which contains tildes).\n       FUNCNEST\n              If set to a numeric value greater than 0, defines  a  maximum  function  nesting  level.\n              Function  invocations  that  exceed this nesting level will cause the current command to\n              abort.\n       GLOBIGNORE\n              A colon-separated list of patterns defining the set of file names to be ignored by path‐\n              name expansion.  If a file name matched by a pathname expansion pattern also matches one\n              of the patterns in GLOBIGNORE, it is removed from the list of matches.\n       HISTCONTROL\n              A colon-separated list of values controlling how commands are saved on the history list.\n              If the list of values includes ignorespace, lines which begin with a space character are\n              not saved in the history list.  A value of ignoredups causes lines matching the previous\n              history  entry  to not be saved.  A value of ignoreboth is shorthand for ignorespace and\n              ignoredups.  A value of erasedups causes all previous lines matching the current line to\n              be  removed from the history list before that line is saved.  Any value not in the above\n              list is ignored.  If HISTCONTROL is unset, or does not include a valid value, all  lines\n              read  by the shell parser are saved on the history list, subject to the value of HISTIG‐\n              NORE.  The second and subsequent lines of a multi-line compound command are not  tested,\n              and are added to the history regardless of the value of HISTCONTROL.\n       HISTFILE\n              The name of the file in which command history is saved (see HISTORY below).  The default\n              value is ~/.bash_history.  If unset, the command history is not saved when a  shell  ex‐\n              its.\n       HISTFILESIZE\n              The  maximum  number  of lines contained in the history file.  When this variable is as‐\n              signed a value, the history file is truncated, if necessary, to  contain  no  more  than\n              that number of lines by removing the oldest entries.  The history file is also truncated\n              to this size after writing it when a shell exits.  If the value is 0, the  history  file\n              is truncated to zero size.  Non-numeric values and numeric values less than zero inhibit\n              truncation.  The shell sets the default value to the value of HISTSIZE after reading any\n              startup files.\n       HISTIGNORE\n              A colon-separated list of patterns used to decide which command lines should be saved on\n              the history list.\n\nSummarize bash in 2 sentences.<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n', params: SamplingParams(n=1, presence_penalty=0.0, frequency_penalty=0.0, repetition_penalty=1.0, temperature=0.7, top_p=0.9, top_k=0, min_p=0.0, seed=None, stop=[], stop_token_ids=[], bad_words=[], include_stop_str_in_output=False, ignore_eos=False, max_tokens=998, min_tokens=0, logprobs=None, prompt_logprobs=None, skip_special_tokens=True, spaces_between_special_tokens=True, truncate_prompt_tokens=None, guided_decoding=None, extra_args=None), prompt_token_ids: None, prompt_embeds shape: None, lora_request: None, prompt_adapter_request: None.
INFO:     127.0.0.1:56000 - "POST /v1/chat/completions HTTP/1.1" 200 OK
INFO 06-15 14:54:59 [async_llm.py:261] Added request chatcmpl-99b1713900ac41e19de798561be81c1d.
INFO 06-15 14:55:05 [loggers.py:116] Engine 000: Avg prompt throughput: 3077.1 tokens/s, Avg generation throughput: 13.1 tokens/s, Running: 0 reqs, Waiting: 0 reqs, GPU KV cache usage: 0.0%, Prefix cache hit rate: 50.0%
INFO 06-15 14:55:15 [loggers.py:116] Engine 000: Avg prompt throughput: 0.0 tokens/s, Avg generation throughput: 0.0 tokens/s, Running: 0 reqs, Waiting: 0 reqs, GPU KV cache usage: 0.0%, Prefix cache hit rate: 50.0%
